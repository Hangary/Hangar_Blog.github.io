<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Search Tree AlgoCommon search structures:  Linked list access: $O(n)$ insert: $O(1)$ search: $O(n)$ (slow)   Array List access: $O(1)$ insert: $O(n)$ (need to copy its original content to a new array,">
<meta property="og:type" content="article">
<meta property="og:title" content="Hangary Blog">
<meta property="og:url" content="http://yoursite.com/2019/03/04/Search Tree Algo/index.html">
<meta property="og:site_name" content="Hangary Blog">
<meta property="og:description" content="Search Tree AlgoCommon search structures:  Linked list access: $O(n)$ insert: $O(1)$ search: $O(n)$ (slow)   Array List access: $O(1)$ insert: $O(n)$ (need to copy its original content to a new array,">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/15520433579778.jpg">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Untitled%20Diagram.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Untitled%20Diagram%20-1-.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Rotation3.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Rotation4.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Rotation%202%20-1-.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/Rotation%202%20-2-.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/AVL-simple-left_K.svg.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/AVL-double-rl_K.svg.png">
<meta property="og:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/height-weight.png">
<meta property="og:updated_time" content="2019-04-30T03:40:20.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hangary Blog">
<meta name="twitter:description" content="Search Tree AlgoCommon search structures:  Linked list access: $O(n)$ insert: $O(1)$ search: $O(n)$ (slow)   Array List access: $O(1)$ insert: $O(n)$ (need to copy its original content to a new array,">
<meta name="twitter:image" content="http://yoursite.com/2019/03/04/Search%20Tree%20Algo/media/15517441780156/15520433579778.jpg">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/03/04/Search Tree Algo/">





  <title> | Hangary Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hangary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/Search Tree Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T18:02:58-06:00">
                2019-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Search-Tree-Algo"><a href="#Search-Tree-Algo" class="headerlink" title="Search Tree Algo"></a>Search Tree Algo</h1><p>Common search structures:</p>
<ol>
<li>Linked list<ul>
<li>access: $O(n)$</li>
<li>insert: $O(1)$</li>
<li>search: $O(n)$ (slow)</li>
</ul>
</li>
<li>Array List<ul>
<li>access: $O(1)$</li>
<li>insert: $O(n)$ (need to copy its original content to a new array, slow)</li>
<li>search: $O(\log n)$</li>
</ul>
</li>
<li><strong>Binary Search Tree</strong><ul>
<li>search/insert/delete: $O(\log n)+ dynamic$, much more effcient</li>
<li>recursive structure: can use compact code to implement</li>
</ul>
</li>
</ol>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>Property 12.5 Binary search never uses more than $|lg N| + 1$ comparisons for a search (hit or miss).</p>
<p>If we need to insert new items dynamically, it seems that we need a linked structure, but a singly linked list does not lead to an efficient implementation, because the efficiency of binary search depends on our ability to get to the middle of any subarray quickly via indexing, and the only way to get to the middle of a singly linked list is to follow links. </p>
<p>To combine the efficiency of binary search with the flexibility of linked structures, we need more complicated data structures: <strong>Search Tree</strong>.</p>
<h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><h4 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h4><p>In BST, there are 2 kinds of nodes:</p>
<ol>
<li><strong><em>Internal node</em></strong>: nodes that contain 2 links that point to other nodes<ul>
<li>(In BST) each node has exactly two links: <strong><em>left</em></strong> and <strong><em>right link</em></strong>s.</li>
<li>Each internal node has an item with a <strong><em>key value</em></strong>, which will be compared with the search key.</li>
</ul>
</li>
<li><strong><em>External node</em></strong> (leaf): nodes that have no links to children nodes<ul>
<li>Links pointing to external nodes are called as <strong><em>null link</em></strong>s.</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Definition 12.2</strong>: A <strong><em>binary search tree (BST)</em></strong> is a binary tree that has a key associated with each of its internal nodes, with the additional property that the key in any node is larger than (or equal to) the keys in all nodes in that node’s left subtree and smaller than (or equal to) the keys in all nodes in that node’s right subtree.</p>
</blockquote>
<p>Other special kinds of tree</p>
<ul>
<li>m-ary tree: each internal node has exactly m children</li>
<li>Ordered tree: all left values &lt; root, all right values &gt; root</li>
<li>Balanced tree: has ≅minimal height for a given number of nodes</li>
<li>Degenerate tree: has ≅maximal height for a given number of nodes</li>
</ul>
<h4 id="Insert-and-Search-in-a-BSTree"><a href="#Insert-and-Search-in-a-BSTree" class="headerlink" title="Insert and Search in a BSTree"></a>Insert and Search in a BSTree</h4><p>The basic function in BST is <strong><em>comparison</em></strong>: both insertions and searches need it.</p>
<p>Characteristics of Insertion in BSTs:</p>
<ul>
<li>New nodes are always attached to null links at the bottom of the tree.</li>
<li>The BST functions do not explicitly check for items with duplicate keys.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BSTree insertR(BSTree t, int v)</span><br><span class="line">if empty return newNode</span><br><span class="line"></span><br><span class="line">if v &lt; t-&gt;value, insertR(t-&gt;left, v)</span><br><span class="line">else if v &gt; t-&gt;value, insertR(t-&gt;right, v)</span><br><span class="line"></span><br><span class="line">return t</span><br></pre></td></tr></table></figure>
<p>For BSTree, <code>search</code> is similar to <code>insert</code>. But there are 2 kinds of <code>search</code>:</p>
<ol>
<li><strong><em>search hit</em></strong>: find the target key value in the path, which is quicker than insertion</li>
<li><strong><em>search miss</em></strong>: cannot find the target key value, which is similar to insertion (both iterate to external nodes)</li>
</ol>
<h4 id="Performance-Characteristics-of-BSTs"><a href="#Performance-Characteristics-of-BSTs" class="headerlink" title="Performance Characteristics of BSTs"></a>Performance Characteristics of BSTs</h4><h5 id="Best-cases-and-Worst-cases-Balanced-or-unbalanced"><a href="#Best-cases-and-Worst-cases-Balanced-or-unbalanced" class="headerlink" title="Best cases and Worst cases: Balanced or unbalanced"></a>Best cases and Worst cases: Balanced or unbalanced</h5><p>The main source of time cost for BSTs is <em>comparison</em>. So the running times of binary search trees are dependent on <u>the shapes of the trees</u>.</p>
<ul>
<li>In the best case where the tree is <em>perfectly balanced</em>, the time cost is $\lg n$, because there are about $\lg N$ nodes between the root and each external node. ==(same as binary search)==</li>
<li>In the worst case where the tree is <em>extremely unbalanced</em> (just has one continuous path), the time cost is $N$, because there are $N$ nodes between the root and the farest external node.</li>
</ul>
<p>These 2 cases are also called:</p>
<ul>
<li>==<strong><em>Balanced tree</em></strong>==: has ≅ minimal height for a given number of nodes</li>
<li>==<strong><em>Degenerate tree</em></strong>==: has ≅ maximal height for a given number of nodes</li>
</ul>
<p>Mathematical definition for balanced tree: $bf=h(L_{ST})-h(R_{ST})$ (bf = balance factor)</p>
<ul>
<li>$|bf| \leq 1$: balanced</li>
<li>$|bf| &gt; 1$: unbalanced</li>
</ul>
<p>Notes: This worst-case arises when we insert keys in order or in reverse order into an initially empty tree, which we should avoid.</p>
<p><img src="media/15517441780156/15520433579778.jpg" alt="-w200"></p>
<h5 id="Average-Performance"><a href="#Average-Performance" class="headerlink" title="Average Performance"></a>Average Performance</h5><p>On average, we can calculate that Insertions and search misses require about $2\ln N$ for a N-key BST.</p>
<p>This means that the search cost for BSTs would be 39% higher than that for binary search for random keys, ==but the extra cost is well worthwhile==, because a new key can be inserted at about the same cost—flexibility not available with binary search.</p>
<h3 id="BST-improvement"><a href="#BST-improvement" class="headerlink" title="BST improvement"></a>BST improvement</h3><h4 id="Alternative-Insertion-Insertion-at-the-Root"><a href="#Alternative-Insertion-Insertion-at-the-Root" class="headerlink" title="Alternative Insertion: Insertion at the Root"></a>Alternative Insertion: Insertion at the Root</h4><p>Now, we consider an alternative insertion method, where each new item be inserted at the root, so recently inserted nodes are at the top of the tree. </p>
<p>This method plays a crucial role in two of the improved BST algorithms.</p>
<p>Let’s consider this process:</p>
<ol>
<li>Suppose that the key of the item to be inserted is larger than the key at the root. </li>
<li>We can make a new tree whose root is the new root node: <ul>
<li>the old root as the left subtree and </li>
<li>the right subtree of the old root as the right subtree.</li>
</ul>
</li>
<li>However, the right subtree may contain some smaller keys, so we need to do extra work to complete the insertion.</li>
<li>Fortunately, there is a simple recursive solution to this problem, which is based on <strong><em>rotation</em></strong>, a fundamental transformation on trees.</li>
</ol>
<p>Advantages:</p>
<ul>
<li>Recently-inserted items are close to root, therefore low cost if recent items more likely to be searched.<ul>
<li>For some applications, search favours recently-added items.</li>
</ul>
</li>
<li>tendency to be balanced, but no balance guarantee.</li>
</ul>
<p>Potential disadvantages: large-scale rearrangement of tree for each insert.</p>
<p>Performance: same complexity as for <em>insertion-at-leaf</em>: $O(height)$</p>
<h4 id="Rebalancing-Trees-Rotation"><a href="#Rebalancing-Trees-Rotation" class="headerlink" title="Rebalancing Trees: Rotation"></a>Rebalancing Trees: Rotation</h4><h5 id="Process-of-a-Roation"><a href="#Process-of-a-Roation" class="headerlink" title="Process of a Roation"></a>Process of a Roation</h5><p><img src="media/15517441780156/Untitled%20Diagram.png" alt="Rotation1 -w350"></p>
<p>First, let’s think about basic properties for a bst:</p>
<ul>
<li><em>LcL</em>&lt;PL&lt;R, PL&lt;<em>LcR</em>&lt;R</li>
<li>R&lt;<em>RcL</em>&lt;PR, R&lt;PR&lt;<em>RcR</em></li>
<li>==This is basically their horizontal position on this tree:==<br><img src="media/15517441780156/Untitled%20Diagram%20-1-.png" alt="Rotation2 -w400"></li>
</ul>
<p>Then, if we want to change <em>PL</em> to its root, we can notice that:</p>
<ul>
<li>Only $LcL &lt; PL$, so LcL would be its left subtree</li>
<li>Since $LcR &lt; R &lt; PR$ (R is mid, more balance), R would be a better root for its right subtree</li>
</ul>
<p><u>As we can see, after rotation, the horizontal position between different nodes do not change, but its root changes:</u></p>
<p><img src="media/15517441780156/Rotation3.png" alt="Rotation3 -w400"></p>
<p>But actually, this process is reversible:</p>
<p><img src="media/15517441780156/Rotation4.png" alt="Rotation4 -w400"></p>
<p>==If we see from downside to upside, we can find that this tree is more <em>balanced</em>, <u>because the root is much closer to the <em>median</em></u>.==</p>
<p>==So generally, what rotation does is to rearrange a bst to make its <em>median</em> higher in a tree, finally always on the top.==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">partition(tree,i):</span><br><span class="line">|  Input  tree with n nodes, index i</span><br><span class="line">|  Output tree with ith item moved to the root</span><br><span class="line">|</span><br><span class="line">|  m=#nodes(left(tree))</span><br><span class="line">|  if i &lt; m then</span><br><span class="line">|     left(tree)=partition(left(tree),i)</span><br><span class="line">|     tree=rotateRight(tree)</span><br><span class="line">|  else if i &gt; m then</span><br><span class="line">|     right(tree)=partition(right(tree),i-m-1)</span><br><span class="line">|     tree=rotateLeft(tree)</span><br><span class="line">|  end if</span><br><span class="line">|  return tree</span><br></pre></td></tr></table></figure>
<p>Analysis of rebalancing: $O(N)$ visits every node</p>
<h5 id="Rotation-and-Double-rotation"><a href="#Rotation-and-Double-rotation" class="headerlink" title="Rotation and Double-rotation"></a>Rotation and Double-rotation</h5><p>Let’s recall <strong><em>balance factor</em></strong>: Balance_factor(Node) = Height(Left_subtree) - Height(Right_subtree)</p>
<p>Instead of just analysing parent and child, we use a new method: considering <em>parent-child-granchild</em> (<strong><em>p-c-g</em></strong> three level analysis)</p>
<p><img src="media/15517441780156/Rotation%202%20-1-.png" alt="Rotation -w600"><br><img src="media/15517441780156/Rotation%202%20-2-.png" alt="Rotation 2 -w600"></p>
<p>As we can see from the graphs, Right rotation is suitable for (+2,+1), and Left rotation is suitable for (-2,-1).</p>
<p><img src="media/15517441780156/AVL-simple-left_K.svg.png" alt="AVL-simple-left_K.svg -w300"></p>
<p>Then what if we encounter (+2,-1) or (-2,+1)? Then we can use <strong><em>double-rotation</em></strong>:</p>
<p><img src="media/15517441780156/AVL-double-rl_K.svg.png" alt="AVL-double-rl_K.svg -w300"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node *<span class="title">rotate_RightLeft</span><span class="params">(node *X, node *Z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Z is by 2 higher than its sibling</span></span><br><span class="line">	Y = left_child(Z); <span class="comment">// Inner child of Z</span></span><br><span class="line">	<span class="comment">// Y is by 1 higher than sibling</span></span><br><span class="line">	t3 = right_child(Y);</span><br><span class="line">	left_child(Z) = t3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t3 != null)		parent(t3) = Z;</span><br><span class="line">	</span><br><span class="line">	right_child(Y) = Z;</span><br><span class="line">	parent(Z) = Y;</span><br><span class="line">	t2 = left_child(Y);</span><br><span class="line">	right_child(X) = t2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t2 != null)		parent(t2) = X;</span><br><span class="line">	</span><br><span class="line">	left_child(Y) = X;</span><br><span class="line">	parent(X) = Y;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BalanceFactor(Y) &gt; <span class="number">0</span>) &#123; <span class="comment">// t3 was higher</span></span><br><span class="line">	    BalanceFactor(X) = –<span class="number">1</span>;  <span class="comment">// t1 now higher</span></span><br><span class="line">	    BalanceFactor(Z) = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">if</span> (BalanceFactor(Y) == <span class="number">0</span>) &#123;</span><br><span class="line">	        BalanceFactor(X) = <span class="number">0</span>;</span><br><span class="line">	        BalanceFactor(Z) = <span class="number">0</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="comment">// t2 was higher</span></span><br><span class="line">        BalanceFactor(X) = <span class="number">0</span>;</span><br><span class="line">        BalanceFactor(Z) = +<span class="number">1</span>;  <span class="comment">// t4 now higher</span></span><br><span class="line">    	&#125;</span><br><span class="line">	BalanceFactor(Y) = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Y; <span class="comment">// return new root of rotated subtree</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Improved-BST-Structures"><a href="#Improved-BST-Structures" class="headerlink" title="Improved BST Structures"></a>Improved BST Structures</h4><ul>
<li><strong><em>Splay tree</em></strong></li>
<li>AVL tree</li>
<li></li>
</ul>
<h5 id="Splay-Tree"><a href="#Splay-Tree" class="headerlink" title="Splay Tree"></a>Splay Tree</h5><p>A <strong><em>splay tree</em></strong> is a self-adjusting bst, which use appropriate double-rotations to improve tree balance. </p>
<ul>
<li>not strictly balanced (unlike AVL tree), just case about parent-child-granchild three levels</li>
<li>very quick to access</li>
<li>reasonable amortized performance, but still has $O(n)$ in worst case</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">insertSplay(tree,item):</span><br><span class="line">|  Input  tree, item</span><br><span class="line">|  Output tree with item splay-inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then return new node containing item</span><br><span class="line">|  else if item=data(tree) then return tree</span><br><span class="line">|  else if item&lt;data(tree) then</span><br><span class="line">|  |  if left(tree) is empty then</span><br><span class="line">|  |     left(tree)=new node containing item</span><br><span class="line">|  |  else if item&lt;data(left(tree)) then</span><br><span class="line">|  |        // Case 1: left-child of left-child</span><br><span class="line">|  |    left(left(tree))=insertSplay(left(left(tree)),item)</span><br><span class="line">|  |     // left(tree)=rotateRight(left(tree))</span><br><span class="line">|  |     tree=rotateRight(tree)</span><br><span class="line">|  |  else  // Case 2: right-child of left-child</span><br><span class="line">|  |     right(left(tree))=insertSplay(right(left(tree)),item)</span><br><span class="line">|  |     left(tree)=rotateLeft(left(tree))</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return rotateRight(tree)  // second rotation</span><br><span class="line">|  else if item&gt;data(tree) then</span><br><span class="line">|  |  if right(tree) is empty then</span><br><span class="line">|  |     right(tree)=new node containing item</span><br><span class="line">|  |  else if item&lt;data(right(tree)) then</span><br><span class="line">|  |        // Case 3: left-child of right-child</span><br><span class="line">|  |     left(right(tree))=insertSplay(left(right(tree)),item)</span><br><span class="line">|  |     right(tree)=rotateRight(right(tree))</span><br><span class="line">|  |  else  // Case 4: right-child of right-child</span><br><span class="line">|  |     right(right(tree))=insertSplay(right(right(tree)),item)</span><br><span class="line">|  |     // right(tree)=rotateLeft(right(tree))</span><br><span class="line">|  |     tree=rotateLeft(tree)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return rotateLeft(tree)   // second rotation</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure>
<h5 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h5><p>An <strong><em>AVL tree</em></strong> (named after inventors <em>A</em>delson-<em>V</em>elsky and <em>L</em>andis) is a self-balancing binary search tree, which is always strictly balanced.</p>
<p>Approach:</p>
<ul>
<li>insertion (at leaves) may cause imbalance</li>
<li>repair balance as soon as we notice imbalance</li>
<li>repairs done locally, not by overall tree restructure</li>
</ul>
<p>==For a AVL tree, imbalance can be repaired by a single rotation (without double-rotations):==</p>
<ul>
<li>if left subtree too high ($bf&gt;+1$), do right rotation</li>
<li>if right subtree too high ($bf&lt;-1$), do left rotation</li>
</ul>
<p>Analysis of AVL trees:</p>
<ul>
<li>Problem: determining height/depth of subtrees may be expensive.</li>
<li>Performance: All operations take $O(\log n)$ time in both the average and worst cases</li>
<li><u>may not be <strong><em>weight-balanced</em></strong>; subtree sizes may differ</u> <img src="media/15517441780156/height-weight.png" alt="height-weight -w400"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">insertAVL(tree,item):</span><br><span class="line">|  Input  tree, item</span><br><span class="line">|  Output tree with item AVL-inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then</span><br><span class="line">|     return new node containing item</span><br><span class="line">|  else if item=data(tree) then</span><br><span class="line">|     return tree</span><br><span class="line">|  else</span><br><span class="line">|  |  // insert item</span><br><span class="line">|  |  if item&lt;data(tree) then</span><br><span class="line">|  |     left(tree)=insertAVL(left(tree),item)</span><br><span class="line">|  |  else if item&gt;data(tree) then</span><br><span class="line">|  |     right(tree)=insertAVL(right(tree),item)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  // repair imbalance, critical</span><br><span class="line">|  |  if height(left(tree))-height(right(tree)) &gt; 1 then</span><br><span class="line">|  |     if item&gt;data(left(tree)) then</span><br><span class="line">|  |        // left of left</span><br><span class="line">|  |        left(tree)=rotateLeft(left(tree))</span><br><span class="line">|  |     end if</span><br><span class="line">|  |     // right of left</span><br><span class="line">|  |     tree=rotateRight(tree)</span><br><span class="line">|  |  else if height(right(tree))-height(left(tree)) &gt; 1 then</span><br><span class="line">|  |     if item&lt;data(right(tree)) then</span><br><span class="line">|  |        right(tree)=rotateRight(right(tree))</span><br><span class="line">|  |     end if</span><br><span class="line">|  |     tree=rotateLeft(tree)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return tree</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-Trees"><a href="#2-3-4-Trees" class="headerlink" title="2-3-4 Trees"></a>2-3-4 Trees</h4><p>A 2-3-4 tree is a variation on the B-Tree, which is a multiway tree in which all non-leaf nodes have 2, 3, or 4 children. </p>
<p>Property of a 2-3-4 tree:</p>
<ul>
<li>Each <em>node</em> stores at most 3 values(<em>entries</em>)<ul>
<li>Number of children = (<em>entries</em> + 1) or (zero)</li>
<li>Each internal node is a 2-node (1 value), 3-node (2 values), or 4-node (3 values).</li>
</ul>
</li>
<li>2-3-4 trees are always balanced.</li>
<li>==All the leaves are on the same level. / In a balanced 2-3-4 tree, all leaves are at same distance from the root.==</li>
</ul>
<p>Insertion into a 2-3-4 Tree: ==2-3-4 trees grow “<em>upwards</em>“ from the leaves.==</p>
<ol>
<li>find leaf node where Item belongs (via search)</li>
<li>if not full (i.e. order &lt; 4), insert Item in this node, order++</li>
<li>if node is full (i.e. contains 3 items) <ol>
<li>split into two 2-nodes as leaves, promote middle element to parent</li>
<li>insert item into appropriate leaf 2-node</li>
<li>then, if parent become a 4-node, continue split/promote upwards</li>
<li>if promote to root, and root is a 4-node, split root node and add new root</li>
</ol>
</li>
</ol>
<p>Performance analysis: <u>worst case determined by height $h$</u></p>
<ul>
<li>worst case for height: all nodes are 2-nodes, similar to balanced BSTs $h ≅ \log_2 n$</li>
<li>best case for height: all nodes are 4-nodes, balanced tree with branching factor 4, $h ≅ \log_4 n$</li>
</ul>
<p>Insertion algorithm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">insert(tree,item):</span><br><span class="line">|  Input  2-3-4 tree, item</span><br><span class="line">|  Output tree with item inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then</span><br><span class="line">|     return new node containing item</span><br><span class="line">|  end if</span><br><span class="line">|  node=Search(tree,item)</span><br><span class="line">|  parent=parent of node</span><br><span class="line">|  if node.order&lt;4 then</span><br><span class="line">|     insert item into node</span><br><span class="line">|     increment node.order</span><br><span class="line">|  else</span><br><span class="line">|  |  promote = node.data[1]     // middle value</span><br><span class="line">|  |  nodeL   = new node containing data[0]</span><br><span class="line">|  |  nodeR   = new node containing data[2]</span><br><span class="line">|  |  if item&lt;node.data[1] then</span><br><span class="line">|  |     insert(nodeL,item)</span><br><span class="line">|  |  else</span><br><span class="line">|  |     insert(nodeR,item)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  insert(parent,promote)</span><br><span class="line">|  |  while parent.order=4 do</span><br><span class="line">|  |     continue promote/split upwards</span><br><span class="line">|  |  end while</span><br><span class="line">|  |  if parent is root ∧ parent.order=4 then</span><br><span class="line">|  |     split root, making new root</span><br><span class="line">|  |  end if</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/03/25/Hashing Algo/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Han">
            
              <p class="site-author-name" itemprop="name">Han</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hangary" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:HangaryLiu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Search-Tree-Algo"><span class="nav-number">1.</span> <span class="nav-text">Search Tree Algo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Binary-Search"><span class="nav-number">1.1.</span> <span class="nav-text">Binary Search</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Binary-Search-Tree"><span class="nav-number">1.1.1.</span> <span class="nav-text">Binary Search Tree</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Terminology"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">Terminology</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Insert-and-Search-in-a-BSTree"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">Insert and Search in a BSTree</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Performance-Characteristics-of-BSTs"><span class="nav-number">1.1.1.3.</span> <span class="nav-text">Performance Characteristics of BSTs</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Best-cases-and-Worst-cases-Balanced-or-unbalanced"><span class="nav-number">1.1.1.3.1.</span> <span class="nav-text">Best cases and Worst cases: Balanced or unbalanced</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Average-Performance"><span class="nav-number">1.1.1.3.2.</span> <span class="nav-text">Average Performance</span></a></li></ol></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#BST-improvement"><span class="nav-number">1.1.2.</span> <span class="nav-text">BST improvement</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Alternative-Insertion-Insertion-at-the-Root"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">Alternative Insertion: Insertion at the Root</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Rebalancing-Trees-Rotation"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">Rebalancing Trees: Rotation</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Process-of-a-Roation"><span class="nav-number">1.1.2.2.1.</span> <span class="nav-text">Process of a Roation</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Rotation-and-Double-rotation"><span class="nav-number">1.1.2.2.2.</span> <span class="nav-text">Rotation and Double-rotation</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Improved-BST-Structures"><span class="nav-number">1.1.2.3.</span> <span class="nav-text">Improved BST Structures</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Splay-Tree"><span class="nav-number">1.1.2.3.1.</span> <span class="nav-text">Splay Tree</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#AVL-Tree"><span class="nav-number">1.1.2.3.2.</span> <span class="nav-text">AVL Tree</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-3-4-Trees"><span class="nav-number">1.1.2.4.</span> <span class="nav-text">2-3-4 Trees</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
