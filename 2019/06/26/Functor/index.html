<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Haskell, 函数式编程,">










<meta name="description" content="从 Functor 到 Applicative 再到 Monad 本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。  大多数 Monad 尝试解决的是 副作用 (side effect) 的问题。 在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 p">
<meta name="keywords" content="Haskell, 函数式编程">
<meta property="og:type" content="article">
<meta property="og:title" content="从 Functor 到 Applicative 再到 Monad">
<meta property="og:url" content="http://yoursite.com/2019/06/26/Functor/index.html">
<meta property="og:site_name" content="Hangary Blog">
<meta property="og:description" content="从 Functor 到 Applicative 再到 Monad 本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。  大多数 Monad 尝试解决的是 副作用 (side effect) 的问题。 在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 p">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-04-03T21:10:00.045Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="从 Functor 到 Applicative 再到 Monad">
<meta name="twitter:description" content="从 Functor 到 Applicative 再到 Monad 本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。  大多数 Monad 尝试解决的是 副作用 (side effect) 的问题。 在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 p">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/06/26/Functor/">





  <title>从 Functor 到 Applicative 再到 Monad | Hangary Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hangary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/Functor/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">从 Functor 到 Applicative 再到 Monad</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T15:13:42-05:00">
                2019-06-26
              </time>
            

            
              <span class="post-meta-divider">|</span>
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-check-o"></i>
              </span>
              
                <span class="post-meta-item-text">更新于&#58;</span>
              
              <time title="更新于" itemprop="dateModified" datetime="2020-04-03T16:10:00-05:00">
                2020-04-03
              </time>
            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="从-Functor-到-Applicative-再到-Monad"><a href="#从-Functor-到-Applicative-再到-Monad" class="headerlink" title="从 Functor 到 Applicative 再到 Monad"></a>从 Functor 到 Applicative 再到 Monad</h1><blockquote>
<p>本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。</p>
</blockquote>
<p>大多数 Monad 尝试解决的是 <strong>副作用 (side effect)</strong> 的问题。</p>
<p>在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 <code>print</code>）或者修改指针中的值。<br>但是，在纯函数式编程中，一个函数只能接收输入、返回输出。</p>
<p>举个最简单的例子，在 python 中，我们可以使用 <code>print</code> 进行 debugging:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: float)</span> -&gt; float:</span></span><br><span class="line">    print(<span class="string">"f was called."</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x: float)</span> -&gt; float:</span></span><br><span class="line">    print(<span class="string">"g was called."</span>)</span><br><span class="line">    <span class="keyword">return</span> x - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这就是一个具有副作用的函数，它们不仅返回了计算后的值，还进行了 <code>print</code>。</p>
<p>那么，问题来了：我们在 Haskell 中如何实现这一过程？</p>
<p>一个最基本的思路是，既然函数式编程不允许副作用，那么我们可以尝试修改输出。我们可以创建两个新的函数 <code>f&#39;</code> 与 <code>g&#39;</code>，并且类型为 <code>f&#39;,g&#39; :: Float -&gt; (Float,String)</code>，其中输出元组的 <code>String</code> 就是我们想要的 debug 信息。</p>
<p>图像表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| f&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">f x  &quot;f was called.&quot;</span><br><span class="line"></span><br><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| g&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">g x  &quot;g was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样子，在运行完 <code>f&#39;</code> 与 <code>g&#39;</code> 后，我们就可以通过打印 String 来知道 debug 信息。</p>
<p>但新的问题随之出现，如果我们想要使用一个 <code>f</code> 和 <code>g</code> 的 <strong>函数组合 (Composition)</strong> ，我们该怎么办？<br>在 python 的实现中，<code>f</code> 的输出值和 <code>g</code> 的输入值都是 <code>float</code>，所以它们可以直接连接。但是在 Haskell 中，<code>f</code> 的输出是 <code>(Float,String)</code>，<code>g</code> 的输入是 <code>Float</code>，这似乎没法直接连接。</p>
<p>最简单粗暴的方式是使用 pattern matching，从输出中提取出我们想要的部分：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f'</span> . g' x = <span class="keyword">let</span> (y,s) = g' x</span><br><span class="line">                (z,t) = f' y </span><br><span class="line">            <span class="keyword">in</span> (z,s++t)</span><br></pre></td></tr></table></figure></p>
<p>图像解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     x</span><br><span class="line">     |</span><br><span class="line">   +---+</span><br><span class="line">   | g&apos;|</span><br><span class="line">   +---+</span><br><span class="line">    |   \   </span><br><span class="line">  +---+  | &quot;g was called.&quot;</span><br><span class="line">  | f&apos;|  |</span><br><span class="line">  +---+  |</span><br><span class="line">   | \   |</span><br><span class="line">   |  \  |</span><br><span class="line">   |  +----+</span><br><span class="line">   |  | ++ |</span><br><span class="line">   |  +----+</span><br><span class="line">   |     |</span><br><span class="line">f (g x) &quot;g was called.f was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是，我们希望抽象出一种方法，从而避免这样繁琐的工作。即，定义一个 <strong>高阶函数</strong> (<strong>higher-order function</strong>，指接收或返回值为函数的函数) ，可以自动将一个普通的函数“升级”为一个更”宽“的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f'</span> :: <span class="type">Float</span> -&gt; (<span class="type">Float</span>,<span class="type">String</span>)</span><br><span class="line"><span class="title">bind</span> :: (<span class="type">Float</span> -&gt; (<span class="type">Float</span>,<span class="type">String</span>)) -&gt; ((<span class="type">Float</span>,<span class="type">String</span>) -&gt; (<span class="type">Float</span>,<span class="type">String</span>))</span><br><span class="line"><span class="title">bind</span> f' :: (<span class="type">Float</span>,<span class="type">String</span>) -&gt; (<span class="type">Float</span>,<span class="type">String</span>)  <span class="comment">-- bind is a higher-order function</span></span><br><span class="line"><span class="title">bind</span> f' (gx,gs) = <span class="keyword">let</span> (fx,fs) = f' gx </span><br><span class="line">                 <span class="keyword">in</span> (fx,gs++fs)</span><br></pre></td></tr></table></figure></p>
<p><code>bind</code> 必须实现两个目的：</p>
<ol>
<li>适配 <code>f&#39;</code> 到 <code>g&#39; x</code> 的结果</li>
<li>将 <code>g&#39;</code> 与 <code>f&#39;</code> 返回的结果关联在一起</li>
</ol>
<p>通过 <code>bind</code> ，我们成功让一个普通的函数 <code>f&#39;</code> 升级成为了一个可以接收更复杂输入的函数。在这里，<code>bind</code> 如同一个胶水，成功的连接了不同的输入在一块。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p><code>Functor</code> 是指一类特殊的类型构造器 (<em>type constructor</em>) 。它可以将某一特定类型的一些值”打包” (<em>wrap</em>) 起来，形成一个上下文 (<em>context</em>)。</p>
<p>一个 <code>Functor</code> 必须具有 kind : <code>* -&gt; *</code>，即接收一个 <strong>实类型 (Concrete type)</strong> ，然后返回一个可以装载这个 concrete type 的 wrapper type。<br>注意，我们现在所讨论的，全都是在类型系统 (type system) 上的概念，和实际的实现无关，即需要分清 wrapper 和 wrapper type 之前的区别。例如，这个 wrapper 的实现可以是 list (linear structure)，tree (branch structure) 甚至是 graph。</p>
<p>让我们来看一下具体实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- kind of f: * -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="comment">-- fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</span></span><br><span class="line">    <span class="comment">-- f :: a -&gt; b</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)  </span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure></p>
<p>对于一个 <code>Functor</code> 的 instance，最重要的函数就是 <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> （这里的 f 就是一个 wrapper type constructor）。<code>fmap</code> 的本质是一个用于”升级”基本函数的高等函数 (higher-order function)。比方说，我们有一个可以用于原始类型 (primitive data type) 的函数 <code>f</code>，那么我们通过 <code>fmap</code> 就可以将 <code>f</code> 升级成对所有 <code>Functor</code> 都适用的函数，这本质是一种多态和抽象的实现。</p>
<p>如果使用盒子比喻，那么我们首先有一些各种颜色的礼物包装纸 （wrapper type constructor），这些包装纸可以帮助我们判断各个礼物的用途，比如粉红色的包装纸是用于情人节礼物，白色的包装是用于朋友间的礼物，这就是所谓的上下文 context。它们像是一个标签，帮助我们理解礼物的作用，而且，在发货时，这些颜色可以确保我们不会发错礼物，保证了类型安全 (type safety)。</p>
<p>但是，这些包装纸并不可以直接用于包装礼物，我们需要让包装纸对礼物的类型进行剪裁和适配，才能用于包装礼物。这里的礼物类型就是 concrete type，通过给包装纸 (wrapper type constructor) 传入一个礼物类型 (concrete type)，我们就得到了一个可以使用的包装纸类型 (wrapper type)。</p>
<p>那么现在有一个问题，假设我们现在开业大酬宾，希望给每一个礼物都加上一个贺卡，那么我们该怎么做？对于尚未包装的礼物，这很简单，直接使用一个加入贺卡函数即可。但是对于已经包装好的礼物，由于所有不同的包装礼物都具有不同的类型，对每一种包装礼物都写一个对应的加入贺卡函数非常麻烦。这个时候，我们可以抽象出一个过程：<code>打开包装 -&gt; 应用函数 fun -&gt; 重新包装</code>，并写出一个高阶函数 <code>fmap</code>，用于接收 <code>应用函数 fun</code> ，然后返回 <code>打开包装 -&gt; 应用函数 fun -&gt; 重新包装</code>。</p>
<p>但实际上，为了实现这个高阶函数 <code>fmap</code>，我们依旧需要对每一个包装礼物类型 (Functor instance type) 写出对应的 <code>fmap</code> 定义。这么一看，似乎并不比”对每一种包装礼物都写一个对应的加入贺卡函数”更加简单？不对，再来考虑一个新的情况，假设我们现在发现贺卡有问题，希望拿出每一个礼物的贺卡，那么如果我们已经写好了 <code>fmap</code>，这个时候可以直接 <code>fmap 拿出贺卡</code>，从而节省了重复的代码，这就是 <code>fmap</code> 抽象的意义。</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Applicative 是对 Functor 的进一步抽象。我们知道，函数式编程的一个特点是函数为第一等公民 (First class function)，函数和值享有同等的地位。那么，既然我们可以“打包”值，那么我们可不可以”打包“一个函数？如果可以，我们该怎么应用这些被”打包”起来的函数？这就是 Applicative 所解决的问题。</p>
<p>我们将能够”打包”一个函数，并将这个”打包”后的函数应用于其他“包裹”的“函数包裹”称呼为 <strong><em>Applicative Functor</em></strong>。</p>
<p>让我们来看一下具体实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- f must be an instance of Functor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    pure :: a -&gt; f a  </span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    pure = <span class="type">Just</span>  </span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span>  </span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure></p>
<p><code>Applicative</code> 中有两个非常重要的函数：</p>
<ul>
<li><code>pure</code>: 用于”打包”一个普通函数。基于<u>构造函数</u> (constructor)实现，但是区别在于 <code>pure</code> 可能会对函数进行一些更进一步的操作。但实际上，如果我们对一个值应用 <code>pure</code>，结果与使用构造函数的结果应该类似。</li>
<li><code>&lt;*&gt;</code>: 基于 <code>fmap</code> 实现，将一个被打包的函数解包，然后使用 <code>fmap</code> 应用在第二个打包的值上。</li>
</ul>
<p>这两个函数看起来似乎并没有什么实际用处，这两个函数能做的，使用上一部分实现的 <code>fmap</code> 也可以做：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span>    <span class="comment">-- Just 12</span></span><br><span class="line"><span class="title">fmap</span> (+<span class="number">3</span>) $ <span class="type">Just</span> <span class="number">9</span>      <span class="comment">-- Just 12</span></span><br></pre></td></tr></table></figure></p>
<p>但假设，我们现在有一个函数 <code>fun :: a -&gt; b -&gt; c</code> 需要接收两个输入值，而我们想要输入两个被包裹的值到 <code>fun</code>。这个函数通过 <code>fmap</code> 很难写出：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> (+) $ <span class="type">Just</span> <span class="number">9</span>   <span class="comment">-- Just (9+)</span></span><br><span class="line"><span class="title">fmap</span> (<span class="type">Just</span> (<span class="number">9</span>+)) (<span class="type">Just</span> <span class="number">3</span>)   <span class="comment">-- do not work!</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们就可以使用 <code>&lt;*&gt;</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(fmap (+) <span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- or more elegant:</span></span><br><span class="line"><span class="title">pure</span> (+) (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>==可以看到，通过 <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>，我们可以优雅地应用一个普通函数 <code>fun</code> 到多个打包值 (wrapper value) 上，而不需要使用 pattern matching！由于 Haskell 的 curried function 特性，我们可以应用具有任意数量参数的函数 <code>fun :: a -&gt; b ... -&gt; output</code>到打包值上。而我们原本 <code>fmap</code> 只能应用接收单个参数的函数 <code>fun :: a -&gt; b</code>到一个打包值，我们的抽象在这里更进一步。==</p>
<p>而且，Haskell 还将具有一个与 <code>fmap</code> 同义的中缀操作符：<code>&lt;$&gt;</code>，于是，我们可以更优雅的改写上面的式子：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(fmap (+) <span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="title">pure</span> (+) (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- equal to</span></span><br><span class="line">(+) &lt;$&gt; (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>为什么我们要把一个普通函数用 <code>Applicative</code> 打包？</p>
<ol>
<li>方便多个 <code>Functotr</code> 作为输入的函数</li>
<li>在函数上应用 context，确保 type safety</li>
<li>确保值的 context 在应用函数前后一致</li>
</ol>
<p>对第2点举个简单的例子，我们有 <code>double :: Int -&gt; Int</code>，我们可以打包其，变成 <code>Calc double</code>，那么，这个函数就只可以应用在 <code>Calc Int</code> 上，从而确保类型安全。</p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>通过 Functor 与 Applicative 这两个抽象，我们已经解决了大部分与”包裹“或者说 context 的问题了：</p>
<ol>
<li>通过 record syntax，我们可以很轻松的将值从 context 中取出</li>
<li>通过 Functor，我们可以在各类不同的 context 下使用同一个基本函数来操作被“包裹”的值 （多态）</li>
<li>通过 Applicative，我们可以在多个被”包裹“的值之间使用基本函数，如加减乘除等等<br>（在这里，基本函数 basic function 指不输入或输出被打包值的函数）</li>
</ol>
<p>但是，这个时候我们可以考虑一类特殊的函数：输入一个普通的值，随后输出一个被”打包“的值的函数。</p>
<p>举个这类函数最简单的例子，为了 debug 我们希望函数 <code>f</code>/<code>g</code> 在输入一个值 <code>x</code> 的时候，不仅输出处理后的结果 <code>y</code>，还会输出 debug 信息，即 <code>f :: Int -&gt; (Int, String)</code>。</p>
<p>图像表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| f&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">f x  &quot;f was called.&quot;</span><br><span class="line"></span><br><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| g&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">g x  &quot;g was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样子，在运行完 f’ 与 g’ 后，我们就可以通过打印 String 来知道 debug 信息。</p>
<p>但这个时候问题出现了，如果我们想要使用一个 f 和 g 的函数组合 (Composition)，我们该怎么办？即，如何应用一个包含上下文的值 <code>m a</code>，到一个接受普通输入，并附增上上下文的函数 <code>fun :: b -&gt; m b</code>。我们之前的 Functor 和 Applicative 都不能处理这类问题。</p>
<p>我们可以从这个函数开始：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: (<span class="type">Monad</span> m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>&gt;&gt;=</code> 也被称为 <code>bind</code>。</p>
<p><code>bind</code> 必须实现两个目的：</p>
<ol>
<li>适配 <code>f&#39;</code> 到 <code>g&#39; x</code> 的结果</li>
<li>将 <code>g&#39;</code> 与 <code>f&#39;</code> 返回的结果关联在一起</li>
</ol>
<p>通过 <code>bind</code> ，我们成功让一个普通的函数 <code>f&#39;</code> 升级成为了一个可以接收更复杂输入的函数。在这里，<code>bind</code> 如同一个胶水，成功的连接了不同的输入在一块。</p>
<p>图像解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     x</span><br><span class="line">     |</span><br><span class="line">   +---+</span><br><span class="line">   | g&apos;|</span><br><span class="line">   +---+</span><br><span class="line">    |   \   </span><br><span class="line">  +---+  | &quot;g was called.&quot;</span><br><span class="line">  | f&apos;|  |</span><br><span class="line">  +---+  |</span><br><span class="line">   | \   |</span><br><span class="line">   |  \  |</span><br><span class="line">   |  +----+</span><br><span class="line">   |  | ++ |</span><br><span class="line">   |  +----+</span><br><span class="line">   |     |</span><br><span class="line">f (g x) &quot;g was called.f was called.&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="安全除法"><a href="#安全除法" class="headerlink" title="安全除法"></a>安全除法</h4><p>再举一个例子：”安全除法“。假设我们现在有一个除法函数 <code>myDiv :: Int -&gt; Int -&gt; Int</code>，接收两个数字，相除后输出。这一切暂时看都起来很美好，但是，问题来了：如果我们第二个数字是 <code>0</code> 呢？一旦出现这种情况，那么程序就会崩溃：<code>Exception: divide by zero</code>。</p>
<p>那么，一个可行解决办法是这样：<code>mySafeDiv :: Int -&gt; Int -&gt; Maybe Int</code>。一旦我们的程序遇到除数为 <code>0</code>，我们就输出 <code>Nothing</code>，以此来确保我们的程序可以正常运行且不会奔溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySafeDiv :: Int -&gt; Int -&gt; Maybe Int</span><br><span class="line">mySafeDiv a b = case b of </span><br><span class="line">                    0 -&gt; Nothing</span><br><span class="line">                    _ -&gt; Just (div a b)</span><br></pre></td></tr></table></figure></p>
<p>（在这里，其实我们引入了一个副作用 side effect，用来表示 failure。这与命令式编程中的 <code>try ... exception</code> 非常相似。）</p>
<p>但是，新的问题出现：如果我们想要连续多次地使用 <code>mySafeDiv</code>，例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mySafeDiv</span> (mySafeDiv <span class="number">1</span> <span class="number">3</span>) (mySafeDiv <span class="number">2</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们所写的这段代码会出现问题，因为 <code>mySafeDiv</code> 的输出类型是 <code>Maybe Int</code>，而我们真正所需要的输入数据是 <code>Int</code>，这里就存在着两个问题：</p>
<ol>
<li>真正的数据被”打包“在了 <code>Maybe</code> 这个 context 里，我们需要“解包” <code>Maybe Int</code>。</li>
<li><code>Maybe Int</code> 可能包含着错误情况 <code>Nothing</code>，这个时候，我们希望不使用 <code>mySafeDiv</code>，而直接返回 <code>Nothing</code></li>
</ol>
<p>首先考虑最直接的写法，创建一个新的 <code>myMaybeSafeDiv</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myMaybeSafeDiv</span> :: <span class="type">Maybe</span> <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">myMaybeSafeDiv</span> a b =</span><br><span class="line">    <span class="keyword">case</span> a <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> v1 -&gt; <span class="keyword">case</span> b <span class="keyword">of</span></span><br><span class="line">                    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">                    <span class="type">Just</span> v2 -&gt; v1 / v2  <span class="comment">-- the real work</span></span><br></pre></td></tr></table></figure></p>
<p>但是，正如我们看到的，这个方法存在两个问题：</p>
<ol>
<li><strong>可读性差</strong>：代码中出现了重复且嵌套的 <code>case ...</code>，并且嵌套会随着参数的增加而增加。这个函数中，真正重要的部分只有最后的 <code>Just v2 -&gt; v1 / v2</code>。</li>
<li><strong>不具有通用性</strong>：如果下一次我们需要写一个类似的函数，如 <code>mySafeLog</code>，那么我们需要这样重复地写一次几乎完全一样的代码。</li>
</ol>
<p>因此，我们需要一个高阶函数，可以将 <code>Maybe Int</code> 强行塞入 <code>mySafeDiv</code> 或 <code>mySafeLog</code> 之类的其他函数，让 <code>Maybe Int</code> 自己自动”解包“或者返回错误。<br>而 <code>bind</code> 函数，就可以帮我们解决这个问题：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span> </span><br><span class="line">    return = <span class="type">Just</span></span><br><span class="line">    <span class="comment">-- definition of bind</span></span><br><span class="line">    <span class="comment">-- f :: a -&gt; Maybe a</span></span><br><span class="line">    m &gt;&gt;= f   = <span class="keyword">case</span> m <span class="keyword">of</span> </span><br><span class="line">                <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span> </span><br><span class="line">                <span class="type">Just</span> x  -&gt; f x</span><br></pre></td></tr></table></figure></p>
<p>当有了 <code>&gt;&gt;=</code> 之后，我们就可以改写之前的嵌套程序，使其正常运行：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- correct version for </span></span><br><span class="line"><span class="comment">-- mySafeDiv (mySafeDiv 1 3) (mySafeDiv 2 0)</span></span><br><span class="line">(mySafeDiv <span class="number">1</span> <span class="number">3</span>) &gt;&gt;= (\x -&gt; </span><br><span class="line">(mySafeDiv <span class="number">2</span> <span class="number">0</span>) &gt;&gt;= (\y -&gt; </span><br><span class="line">(mySafeDiv x y)))</span><br></pre></td></tr></table></figure></p>
<p>这段代码看上去十分绕脑筋，让我们来分析一下这里发生了什么：</p>
<ol>
<li>首先，我们使用 <code>(mySafeDiv 1 3)</code>，产生了一个 <code>Maybe Int</code> 类型的数据</li>
<li>随后，我们使用 <code>&gt;&gt;=</code> 提取出 <code>(mySafeDiv 1 3)</code> 中包含的 <code>0</code>，输入到 <code>(\x -&gt; (mySafeDiv 2 0) &gt;&gt;= (\y -&gt; (mySafeDiv x y))</code> 中，得到 <code>(mySafeDiv 2 0) &gt;&gt;= (\y -&gt; (mySafeDiv 0 y))</code></li>
<li>随后，计算得出 <code>(mySafeDiv 2 0)</code> 为 <code>Nothing</code>，<code>&gt;&gt;=</code> 通过定义，直接输出了 <code>Nothing</code></li>
</ol>
<p>如何形象地理解这一过程，我们可以使用一个简单的比喻：</p>
<ol>
<li>假设我们有着一系列可以对手机（数据）进行各类质量检测的机器（函数），我们的机器检测完输入的手机后，输出时会给手机加上一些标签（上下文 context），用来记录手机是否是完好的</li>
<li>问题在于，我们机器的传感器只能检测单纯的手机，而不能检测贴上有标签的手机。于是，我们可以安装上一系列自动机器手 <code>&gt;&gt;=</code>，<code>&gt;&gt;=</code> 会自动把质量不合格的手机扔掉，然后移除质量合格的手机上的标签，方便下一个机器检测。</li>
<li>但自动机器手不能把手机自动移往下一个机器，，因此，我们还需要一个传送带 <code>\x -&gt; nextMachine x</code>（Lambda 匿名函数），将移除标签后的手机运输到下一个检测机器。</li>
</ol>
<p>当你运行这段代码，你会得到 <code>Nothing</code>！很神奇，不是吗？我们通过 <code>Maybe</code> 的 <code>Monad</code> 性质，成功地将会产生副作用的单个函数组成在一起，形成了一个可以产生相同副作用的大型函数。</p>
<p>而且 Haskell 还提供了一个语法糖：<code>do</code>，让你可以轻松得应用多个 Monad 到多参数函数上，且不需要写繁琐的 lambda 函数。例如，我们可以改写上面的代码为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> </span><br><span class="line">    x &lt;- mySafeDiv <span class="number">1</span> <span class="number">3</span></span><br><span class="line">    y &lt;- mySafeDiv <span class="number">2</span> <span class="number">0</span></span><br><span class="line">    mySafeDiv x y</span><br></pre></td></tr></table></figure></p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Haskell-函数式编程/" rel="tag"># Haskell, 函数式编程</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/01/25/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/09/05/Python 与 Flask 中的上下文（上）/" rel="prev" title="Python 与 Flask 中的上下文（上）">
                Python 与 Flask 中的上下文（上） <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Han</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hangary" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:HangaryLiu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#从-Functor-到-Applicative-再到-Monad"><span class="nav-number">1.</span> <span class="nav-text">从 Functor 到 Applicative 再到 Monad</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Functor"><span class="nav-number">1.1.</span> <span class="nav-text">Functor</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Applicative"><span class="nav-number">1.2.</span> <span class="nav-text">Applicative</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Monad"><span class="nav-number">1.3.</span> <span class="nav-text">Monad</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#安全除法"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">安全除法</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
