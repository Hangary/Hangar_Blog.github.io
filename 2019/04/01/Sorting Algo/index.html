<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Sorting AlgoSorting involves arranging a collection of items in order  based on some property of the item (e.g. key) using an ordering relation on that property  Why is sorting useful?  speeds up subs">
<meta property="og:type" content="article">
<meta property="og:title" content="Hangary Blog">
<meta property="og:url" content="http://yoursite.com/2019/04/01/Sorting Algo/index.html">
<meta property="og:site_name" content="Hangary Blog">
<meta property="og:description" content="Sorting AlgoSorting involves arranging a collection of items in order  based on some property of the item (e.g. key) using an ordering relation on that property  Why is sorting useful?  speeds up subs">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15550378379676.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15550378979174.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15558964076378.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15550379735229.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15559006636164.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15576327661565.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547150539159.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547157701660.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547158401260.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15559065398781.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15559068169195.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15548962723804.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15548966926365.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15548968146927.jpg">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547162716588.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547882455257.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547866806568.png">
<meta property="og:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15547874455855.png">
<meta property="og:updated_time" content="2019-05-15T11:14:01.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hangary Blog">
<meta name="twitter:description" content="Sorting AlgoSorting involves arranging a collection of items in order  based on some property of the item (e.g. key) using an ordering relation on that property  Why is sorting useful?  speeds up subs">
<meta name="twitter:image" content="http://yoursite.com/2019/04/01/Sorting%20Algo/media/15541784881323/15550378379676.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2019/04/01/Sorting Algo/">





  <title> | Hangary Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hangary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/Sorting Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline"></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T23:14:48-05:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Sorting-Algo"><a href="#Sorting-Algo" class="headerlink" title="Sorting Algo"></a>Sorting Algo</h1><p>Sorting involves arranging a collection of items in order</p>
<ul>
<li>based on some property of the item (e.g. key)</li>
<li>using an ordering relation on that property</li>
</ul>
<p>Why is sorting useful?</p>
<ul>
<li>speeds up subsequent searching (binary searching need a sorted list)</li>
<li>arranges data in a human-useful way (e.g. list of students in a tutor class, ordered by family-name or id)</li>
<li>provides intermediate step for advanced algorithms (e.g. duplicate detection/removal, many DBMS operations)</li>
</ul>
<p>Properties of sorting algorithms: <em>stable</em>, <em>adaptive</em>, <em>in-place</em></p>
<ul>
<li><strong><em>Stable</em></strong>: if two items have duplicate keys, their relative order would not change in the sorted array. <ul>
<li>let $x = a[i]$, $y = a[j]$, $key(x) == key(y)$, if $x$ precedes $y$ in $a$, then $x$ precedes $y$ in $a’$</li>
<li>This is particularly useful to repeated sorting different keys for an array.</li>
</ul>
</li>
<li><strong><em>Adaptive</em></strong>: whether it takes advantage of existing order in its input<ul>
<li>behaviour/performance of algorithm affected by data values</li>
<li>i.e. <u>best/average/worst case performance differs</u></li>
<li>e.g. bubble sort</li>
</ul>
</li>
<li><strong><em>In-place sorting</em></strong>: no additional storage space is needed to perform sorting.<ul>
<li>Accordingly, <strong><em>out-place sorting</em></strong> needs to create a copy of array to create a new array.</li>
</ul>
</li>
<li><strong><em>Comparison-based sorting</em></strong>: A comparison sort is a type of sorting algorithm that only reads the list elements through a single abstract <strong>comparison</strong> operation (often a “less than or equal to” operator or a three-way comparison) that determines which of two elements should occur first in the final sorted list. </li>
</ul>
<p>Why stable is important:</p>
<blockquote>
<p>Suppose we have a list of first and last names. We are asked to sort “by last name, then by first”. We could first sort (stable or unstable) by the first name, then stable sort by the last name. After these sorts, the list is primarily sorted by the last name. However, where last names are the same, the first names are sorted.</p>
</blockquote>
<p>Some other properties:</p>
<p>Two major classes of sorting algo: $O(n^2)$, $O(n \log n)$</p>
<ul>
<li>$O(n^2)$ are acceptable if $n$ is small (hundreds)</li>
</ul>
<p>Basic framework for Sorting:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we deal with generic Items</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstractions to hide details of Items</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key(A) (A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> less(A,B) (key(A) &lt; key(B))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(A,B) &#123;Item t; t = A; A = B; B = t;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swil(A,B) &#123;<span class="meta-keyword">if</span> (less(A,B)) swap(A,B);&#125;</span></span><br><span class="line"><span class="comment">// swil = SWap If Less</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sorts a slice of an array of Items</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for sortedness (to validate functions)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSorted</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Two key sorting abstractions:</p>
<ul>
<li><code>Compare</code>: whether item <code>v</code> is less than <code>w</code></li>
<li><code>Swap</code>: swap item <code>v</code> and <code>w</code> in array <code>a[]</code></li>
</ul>
<h2 id="Elementary-Sorting-Algo"><a href="#Elementary-Sorting-Algo" class="headerlink" title="Elementary Sorting Algo"></a>Elementary Sorting Algo</h2><p>To describe simple sorting, we use diagrams like:<img src="media/15541784881323/15550378379676.png" alt="-w600"></p>
<p>In these algorithms:</p>
<ul>
<li>a <strong><em>segment</em></strong> of the array is already sorted, which we do not need to consider any more</li>
<li>each <strong><em>iteration</em></strong> makes more of the array sorted</li>
</ul>
<p>Performance of elementary: $O(n^k)$ where $k &gt; 1$</p>
<h3 id="Selection-Sort-Simple-non-adaptive-method"><a href="#Selection-Sort-Simple-non-adaptive-method" class="headerlink" title="Selection Sort: Simple non-adaptive method"></a>Selection Sort: Simple non-adaptive method</h3><p>Basic Idea:<br>For every iteration:</p>
<ol>
<li>find the smallest element in the <em>unsorted segment</em>, put it into the last slot of the <em>sorted segment</em></li>
<li>repeat until all elements are in the sorted segment</li>
</ol>
<p><img src="media/15541784881323/15550378979174.png" alt="-w500"></p>
<p>Performance: $O(n^2)$, not adaptive</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, min;</span><br><span class="line">   <span class="keyword">for</span> (i = lo; i &lt; hi<span class="number">-1</span>; i++) &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt;= hi; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (less(a[j],a[min])) min = j;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(a[i], a[min]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bubble-Sort-Simple-adaptive-method"><a href="#Bubble-Sort-Simple-adaptive-method" class="headerlink" title="Bubble Sort: Simple adaptive method"></a>Bubble Sort: Simple adaptive method</h3><p>Simple adaptive method:<br>For every iteration:</p>
<ul>
<li>elements move until they meet a smaller element, eventually <code>i</code>th smallest element moves to <code>i</code>th position<ul>
<li>those small elements are in the sorted segment</li>
</ul>
</li>
<li>repeat until there are no swaps during one iteration (already completely sorted)</li>
</ul>
<p>==This idea is basically same as the insertion sort (move smaller elements to the sorted segment), but the advantage is that bubble sort could jump some already sorted elements.==</p>
<p><img src="media/15541784881323/15558964076378.png" alt="-w500"></p>
<p><img src="media/15541784881323/15550379735229.png" alt="-w500"></p>
<p>Performance: </p>
<ul>
<li>best case: $O(n)$, the array is already sorted</li>
<li>worst case: $O(n^2)$, the array is <u>reverse sorted</u></li>
</ul>
<h3 id="Insertion-Sort-Simple-adaptive-method"><a href="#Insertion-Sort-Simple-adaptive-method" class="headerlink" title="Insertion Sort: Simple adaptive method"></a>Insertion Sort: Simple adaptive method</h3><p>Basic ideas: </p>
<ul>
<li>First, take first element and treat as sorted segment (length 1).</li>
<li>Then, for every iteration:<ul>
<li>insert the first element in the <em>unsorted segment</em> into <u>the correct position</u> in the <em>sorted segment</em></li>
<li>repeat until whole array is sorted</li>
</ul>
</li>
</ul>
<p>Steps:<br>Iterate from <code>0</code> to <code>N-1</code>, totally <code>N</code> runs</p>
<ol>
<li>In iteration <code>i</code>, swap <code>a[i]</code> with each larger entry to its left</li>
<li>Continually compare and swap, until it is smaller than its left</li>
<li>Move <code>i</code> to <code>i+1</code>, repeat</li>
</ol>
<p>==Insertion sort is like the combination of reverse bubble sort and selection sort, where you use bubble in the sorted segment.==</p>
<p><img src="media/15541784881323/15559006636164.png" alt="-w500"></p>
<p>Performance:</p>
<ul>
<li>Key operations: For a randomly-ordered array with distinct keys, insertion sort uses $\dfrac{N^2}{4}$ compares and $\dfrac{N^2}{4}$ exchanges on average</li>
<li>best case: $O(n)$, the list is already sorted</li>
<li>worst case: $O(n^2)$, the list is <u>reverse sorted</u></li>
<li>==Note: The advantage that insertion sort has over bubble sort is that, when the list is <u>mostly sorted</u>, bubble sort still need to <strong><em>swap</em></strong> many times, while insertion sort can jump most of those compares and <strong><em>insert</em></strong> directly.==</li>
</ul>
<p>Insertion sort:</p>
<ul>
<li>based on exchanges that only involve adjacent items</li>
<li>already improved above by using moves rather than swaps</li>
<li>“long distance” moves may be more efficient</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, val;</span><br><span class="line">   <span class="keyword">for</span> (i = lo+<span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">      val = a[i];</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt; lo; j--) &#123;</span><br><span class="line">         <span class="keyword">if</span> (val &gt;= a[j<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">         a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      a[j] = val;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Inversions-and-Partially-sorted-Array"><a href="#Inversions-and-Partially-sorted-Array" class="headerlink" title="Inversions and Partially sorted Array"></a>Inversions and Partially sorted Array</h4><p>An <strong><em>inversion</em></strong> is a pair of keys that are out of order.</p>
<p><img src="media/15541784881323/15576327661565.jpg" alt="-w600"></p>
<p>An array is <strong><em>partially sorted</em></strong> if the number of inversions is ≤ c N.</p>
<p>==For partially-sorted arrays, insertion sort runs in linear time. The number of exchanges equals the number of inversions.==</p>
<h3 id="Shell-Sort-Improving-Insertion-Sort"><a href="#Shell-Sort-Improving-Insertion-Sort" class="headerlink" title="Shell Sort: Improving Insertion Sort"></a>Shell Sort: Improving Insertion Sort</h3><p>Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.</p>
<p>Basic idea:</p>
<ul>
<li>array is <code>h</code>-sorted if taking every <code>h</code>‘th element yields a sorted array<ul>
<li>A 1-sorted array is a completely sorted array.</li>
</ul>
</li>
<li>an <code>h</code>-sorted array is made up of <code>n/h</code> interleaved sorted arrays</li>
</ul>
<p>For every iteration: </p>
<ul>
<li>Insertion sort <code>h</code>-sort array for progressively smaller <code>h</code>, ending with <code>1</code>-sorted.</li>
</ul>
<p>The reason we use Insertion sort for every run:</p>
<ol>
<li>For big <code>h</code>, subarray is small</li>
<li>For small <code>h</code>, subarray is nearly in order (require <strong>adaptability</strong>)</li>
<li>For every <code>h</code>, we need to ensure that the previous sorts remain in order. (require <strong>stability</strong>)</li>
</ol>
<p>Performance: </p>
<ul>
<li>depends on the sequence of <code>h</code> values</li>
<li>not yet been fully analysed</li>
<li>from $O(n^{3/2})$ to $O(n^{4/3})$<ul>
<li>Therefore, it is <strong>very efficient for medium-sized arrays</strong>, though not so useful for large-sized arrays</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> hvals[<span class="number">8</span>] = &#123;<span class="number">701</span>, <span class="number">301</span>, <span class="number">132</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> g, h, start, i, j, val;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (g = <span class="number">0</span>; g &lt; <span class="number">8</span>; g++) &#123;</span><br><span class="line">      h = hvals[g];</span><br><span class="line">      start = lo + h;</span><br><span class="line">      <span class="keyword">for</span> (i = start; i &lt; hi; i++) &#123;</span><br><span class="line">         val = a[i];</span><br><span class="line">         <span class="keyword">for</span> (j = i; j &gt;= start &amp;&amp; less(val,a[j-h]); j -= h)</span><br><span class="line">            move(a, j, j-h);</span><br><span class="line">         a[j] = val;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Summary-of-elementary-sorting-Algo"><a href="#Summary-of-elementary-sorting-Algo" class="headerlink" title="Summary of elementary sorting Algo"></a>Summary of elementary sorting Algo</h3><table>
<thead>
<tr>
<th></th>
<th>#compares</th>
<th>-</th>
<th>-</th>
<th>#swaps</th>
<th>-</th>
<th>-</th>
<th>#moves</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>min</td>
<td>avg</td>
<td>max</td>
<td>min</td>
<td>avg</td>
<td>max</td>
<td>min</td>
<td>avg</td>
<td>max</td>
</tr>
<tr>
<td>Selection sort</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$n$</td>
<td>$n$</td>
<td>$n$</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>Bubble sort</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$0$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>Insertion sort</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
</tr>
<tr>
<td>Shell sort</td>
<td>$n$</td>
<td>$n^{4/3}$</td>
<td>$n^{4/3}$</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>$1$</td>
<td>$n^{4/3}$</td>
<td>$n^{4/3}$</td>
</tr>
</tbody>
</table>
<h2 id="Advanced-Sorting-Algo"><a href="#Advanced-Sorting-Algo" class="headerlink" title="Advanced Sorting Algo"></a>Advanced Sorting Algo</h2><p>Advanced sorting algo can achieve better performance than $O(n^k)\ (k&gt;1)$, which is $O(n\log n)$.</p>
<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>Quick sorting is not a stable or adaptive sorting algo.</p>
<p>Basic ideas:</p>
<ol>
<li>Pick a value <code>x</code> as <strong><em>pivot</em></strong></li>
<li>Use the pivot to <strong><em>partition</em></strong> the array into 2 parts (<code>&lt;x</code> and <code>&gt;x</code>)</li>
<li>Recursively sort each of the partitions</li>
</ol>
<h4 id="Vanilla-Quick-Sort"><a href="#Vanilla-Quick-Sort" class="headerlink" title="Vanilla Quick Sort"></a>Vanilla Quick Sort</h4><p>Vanilla Quick Sort is the most simple quick sort, where we <u>pick the first value of the list as the pivot</u>.</p>
<p><img src="media/15541784881323/15547150539159.png" alt="-w400"></p>
<p>Partition is the most important part of quick sorting:<br><img src="media/15541784881323/15547157701660.png" alt="-w400"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i; <span class="comment">// index of pivot</span></span><br><span class="line">   <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">   i = partition(a, lo, hi);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Item v = a[lo];  <span class="comment">// pivot</span></span><br><span class="line">    <span class="keyword">int</span>  i = lo+<span class="number">1</span>, j = hi;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// let i point to the item greater than mid</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[i], v) &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="comment">// let j point to the item smaller than mid</span></span><br><span class="line">        <span class="keyword">while</span> (less(v, a[j]) &amp;&amp; j &gt; i) j--;</span><br><span class="line">        <span class="comment">// if i and j meet, end</span></span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    j = less(a[i],v) ? i : i<span class="number">-1</span>;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Performance:</p>
<ul>
<li>Best case: $O(n\log n)$ comparisons<ul>
<li>choice of pivot gives two equal-sized partitions</li>
<li>same happens at every recursive level</li>
<li>each “level” requires approx n comparisons</li>
<li>halving at each level ⇒ log2n levels</li>
</ul>
</li>
<li>Worst case: $O(n^2)$ comparisons<ul>
<li>==always choose lowest/highest value for pivot==</li>
<li>partitions are size 1 and n-1</li>
<li>each “level” requires approx n comparisons</li>
<li>partitioning to 1 and n-1 ⇒ n levels</li>
</ul>
</li>
</ul>
<h4 id="Improved-Qucik-Sort"><a href="#Improved-Qucik-Sort" class="headerlink" title="Improved Qucik Sort"></a>Improved Qucik Sort</h4><h5 id="Handle-max-min-pivot-Median-of-three"><a href="#Handle-max-min-pivot-Median-of-three" class="headerlink" title="Handle max/min pivot: Median-of-three"></a>Handle max/min pivot: Median-of-three</h5><p><em>Choice of pivot</em> can have significant effect: always choosing largest/smallest ⇒ worst case, which </p>
<p>So we need to try to find “intermediate” value.</p>
<p>One way is to choose pivot by median-of-three:</p>
<p><img src="media/15541784881323/15547158401260.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">medianOfThree</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> (less(a[mid],a[lo])) swap(a, lo, mid);</span><br><span class="line">   <span class="keyword">if</span> (less(a[hi],a[mid])) swap(a, mid, hi);</span><br><span class="line">   <span class="keyword">if</span> (less(a[mid],a[lo])) swap(a, lo, mid);</span><br><span class="line">   <span class="comment">// now, we have a[lo] &lt; a[mid] &lt; a[hi]</span></span><br><span class="line">   <span class="comment">// swap a[mid] to a[lo+1] to use as pivot</span></span><br><span class="line">   swap(a, mid, lo+<span class="number">1</span>); swap(a, lo, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (hi-lo &lt; Threshhold) &#123; ... <span class="keyword">return</span>; &#125;</span><br><span class="line">   medianOfThree(a, lo, hi);</span><br><span class="line">   i = partition(a, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Handle-small-partitions-differently"><a href="#Handle-small-partitions-differently" class="headerlink" title="Handle small partitions differently"></a>Handle small partitions differently</h5><p>Another source of inefficiency:</p>
<ul>
<li>pushing recursion down to very small partitions</li>
<li>overhead in recursive function calls</li>
<li>little benefit from partitioning when size &lt; 5<br>Solution: handle small partitions differently</li>
<li>switch to <strong><em>insertion sort</em></strong> on small partitions, or</li>
<li>don’t sort yet; use post-quicksort insertion sort</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (hi-lo &lt; Threshhold) &#123;</span><br><span class="line">      insertionSort(a, lo, hi);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   medianOfThree(a, lo, hi);</span><br><span class="line">   i = partition(a, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Handle-Duplicate-keys-Three-way-partitioning"><a href="#Handle-Duplicate-keys-Three-way-partitioning" class="headerlink" title="Handle Duplicate keys: Three-way partitioning"></a>Handle Duplicate keys: Three-way partitioning</h5><p>If the array contains many duplicate keys</p>
<ul>
<li>standard partitioning does not exploit this: <img src="media/15541784881323/15559065398781.png" alt="-w500"></li>
<li>can improve performance via <strong><em>three-way partitioning</em></strong>: <a href="media/15541784881323/15559065425556.png">-w500</a></li>
</ul>
<p>Bentley/McIlroy approach to three-way partition:<br><img src="media/15541784881323/15559068169195.png" alt="-w500"></p>
<h4 id="Non-recursive-Quicksort"><a href="#Non-recursive-Quicksort" class="headerlink" title="Non-recursive Quicksort"></a>Non-recursive Quicksort</h4><p>Quick sort can be implemented using an explicit stack:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksortStack</span> <span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;  Stack s = newStack();</span><br><span class="line">   StackPush(s,hi); StackPush(s,lo);</span><br><span class="line">   <span class="keyword">while</span> (!StackEmpty(s)) &#123;</span><br><span class="line">      lo = StackPop(s);</span><br><span class="line">      hi = StackPop(s);</span><br><span class="line">      <span class="keyword">if</span> (hi &gt; lo) &#123; </span><br><span class="line">         i = partition (a,lo,hi);</span><br><span class="line">         StackPush(s,hi); StackPush(s,i+<span class="number">1</span>);</span><br><span class="line">         StackPush(s,i<span class="number">-1</span>); StackPush(s,lo);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>Basic idea: (like reverted Quicksort)</p>
<ol>
<li>split the array into two equal-sized partitions until <u>every partition is sorted</u></li>
<li>(recursively) sort each half</li>
<li><strong><em>merge</em></strong> the two partitions back to original array</li>
</ol>
<p><strong><em>Merging</em></strong> is the critical step.<br>Example of a in-place merging:<br>Suppose we have 2 sorted subarrays: <code>a[lo] - a[mid]</code> and <code>a[mid+1] - a [hi]</code> <img src="media/15541784881323/15548962723804.jpg" alt="-w500"></p>
<ol>
<li><p>copy this array into one auxiliary array <code>aux</code>, and make pointers <code>i</code> and <code>j</code> to the smallest values of 2 subarrays <img src="media/15541784881323/15548966926365.jpg" alt="-w550"></p>
</li>
<li><p>(recursively) copy the smaller of the two pointers, and increment the pointer <img src="media/15541784881323/15548968146927.jpg" alt="-w550"></p>
</li>
<li><p>when one exhausted, copy the rest of the other</p>
</li>
</ol>
<p>==In mergesort, sorting is implemented by merging.== They are equivalent.</p>
<p><img src="media/15541784881323/15547162716588.png" alt=""></p>
<p><strong><em>In-place merging</em></strong>: Actually, we can just use two arrays to implement the merge sort to use less memory.</p>
<p>Best case: $O(N\log N)$ comparisons</p>
<ul>
<li>split array into equal-sized partitions</li>
<li>same happens at every recursive level</li>
<li>each “level” requires ≤ N comparisons</li>
<li>halving at each level ⇒ log2N levels</li>
</ul>
<p>Worst case: $O(N\log N)$ comparisons</p>
<ul>
<li>partitions are exactly interleaved</li>
<li>need to compare all the way to end of partitions</li>
</ul>
<p>Disadvantage over quicksort: need extra storage $O(N)$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>; <span class="comment">// mid point</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    mergesort(a, lo, mid);</span><br><span class="line">    mergesort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">32</span>,<span class="number">45</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">94</span>,<span class="number">78</span>,<span class="number">64</span>,<span class="number">25</span>,<span class="number">55</span>,<span class="number">42</span>&#125;;</span><br><span class="line">mergesort(nums, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i, j, k, nitems = hi-lo+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// in-place merge just one additional array</span></span><br><span class="line">    Item *tmp = <span class="built_in">malloc</span>(nitems*<span class="keyword">sizeof</span>(Item));</span><br><span class="line"></span><br><span class="line">    i = lo; j = mid+<span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// scan both segments, copying to tmp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i],a[j]))</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy items from unfinished segment</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) tmp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy tmp back to main array</span></span><br><span class="line">    <span class="keyword">for</span> (i = lo, k = <span class="number">0</span>; i &lt;= hi; i++, k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Non-recursive-Mergesort-Bottom-up-mergesort"><a href="#Non-recursive-Mergesort-Bottom-up-mergesort" class="headerlink" title="Non-recursive Mergesort: Bottom-up mergesort ?"></a>Non-recursive Mergesort: Bottom-up mergesort ?</h4><p>Non-recursive mergesort does not require a stack, because partition boundaries can be computed iteratively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(A,B) ((A &lt; B) ? A : B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lo is the first index, hi is the last index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, m; <span class="comment">// m = length of runs</span></span><br><span class="line">   <span class="keyword">int</span> end; <span class="comment">// end of 2nd run</span></span><br><span class="line">   <span class="keyword">for</span> (m = <span class="number">1</span>; m &lt;= lo-hi; m = <span class="number">2</span>*m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = lo; i &lt;= hi-m; i += <span class="number">2</span>*m) &#123;</span><br><span class="line">         end = min(i+<span class="number">2</span>*m<span class="number">-1</span>, hi);</span><br><span class="line">         merge(a, i, i+m<span class="number">-1</span>, end); <span class="comment">// this still need a tmp array</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i, j, k, nitems = hi-lo+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// in-place merge just one additional array</span></span><br><span class="line">    Item *tmp = <span class="built_in">malloc</span>(nitems*<span class="keyword">sizeof</span>(Item));</span><br><span class="line"></span><br><span class="line">    i = lo; j = mid+<span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// scan both segments, copying to tmp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i],a[j]))</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy items from unfinished segment</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) tmp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy tmp back to main array</span></span><br><span class="line">    <span class="keyword">for</span> (i = lo, k = <span class="number">0</span>; i &lt;= hi; i++, k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mergesort-Variation"><a href="#Mergesort-Variation" class="headerlink" title="Mergesort Variation"></a>Mergesort Variation</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lo is the first index, hi is the last index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   Item *aux = <span class="built_in">malloc</span>((hi+<span class="number">1</span>)*<span class="keyword">sizeof</span>(Item));</span><br><span class="line">   <span class="keyword">for</span> (i = lo; i &lt;= hi; i++) aux[i] = a[i];</span><br><span class="line">   doMergeSort(a, aux, lo, hi);</span><br><span class="line">   <span class="built_in">free</span>(aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doMergeSort</span><span class="params">(Item a[], Item b[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if not need sort, return</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// otherwise, merge sort</span></span><br><span class="line">    <span class="comment">// find the mid</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// mergesort two partitions</span></span><br><span class="line">    doMergeSort(b, a, lo, mid);</span><br><span class="line">    doMergeSort(b, a, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// merge those sorted arrays</span></span><br><span class="line">    merge(b+lo, mid-lo+<span class="number">1</span>, b+mid+<span class="number">1</span>, hi-mid, a+lo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// what actually sorts array</span></span><br><span class="line"><span class="comment">// merge arrays a[] and b[] into c[]</span></span><br><span class="line"><span class="comment">// aN = size of a[], bN = size of b[]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> aN, Item b[], <span class="keyword">int</span> bN, Item c[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// index into a[]</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// index into b[]</span></span><br><span class="line">    <span class="keyword">int</span> k; <span class="comment">// index into c[] </span></span><br><span class="line">    <span class="keyword">for</span> (i = j = k = <span class="number">0</span>; k &lt; aN+bN; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == aN)</span><br><span class="line">            c[k] = b[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == bN)</span><br><span class="line">            c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(a[i],b[j]))</span><br><span class="line">            c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[k] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>Previous sorts all assume …</p>
<ul>
<li>efficient random access to Items</li>
<li>which suggests that data is in arrays in memory</li>
<li>which limits sortable data to what fits in memory</li>
</ul>
<p>When the data is in disk files</p>
<ul>
<li>random access is inefficient (files are sequential access)</li>
<li>but max data size is far less constrained</li>
</ul>
<p>Because mergesort makes multiple sequential passes, it adapts well as a sorting approach for files.</p>
<p>External mergesort basic idea:</p>
<ul>
<li>have two files, A and B, which alternate as input/output</li>
<li>scan input, sorting adjacent pairs, write to output</li>
<li>scan input, merging pairs to sorted runs of length 4</li>
<li>scan input, merging pairs to sorted runs of length 8</li>
<li>repeat until entire file is sorted</li>
</ul>
<p>How many iterations are needed?</p>
<ul>
<li>double scan length until ≥ file size ($N$ Items)</li>
<li>#iterations =  $\log_2N$</li>
</ul>
<p><img src="media/15541784881323/15547882455257.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="built_in">stdin</span>, containing N Items</span><br><span class="line">Output: stream of Items on <span class="built_in">stdout</span></span><br><span class="line"></span><br><span class="line">copy <span class="built_in">stdin</span> file to A</span><br><span class="line">runLength = <span class="number">1</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (runLength &lt; N) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        inFile = A, outFile = B</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inFile = B, outFile = A</span><br><span class="line">    fileMerge(inFile, outFile, runLength, N)</span><br><span class="line">    iter++;</span><br><span class="line">    runLength *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">copy outfile to <span class="built_in">stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assumes N = 2^k for some integer k &gt; 0</span></span><br><span class="line">fileMerge(inFile, outFile, runLength, N)</span><br><span class="line">&#123;</span><br><span class="line">   inf1 = open inFile <span class="keyword">for</span> reading</span><br><span class="line">   inf2 = open inFile <span class="keyword">for</span> reading</span><br><span class="line">   outf = open outFile <span class="keyword">for</span> writing</span><br><span class="line">   in1 = <span class="number">0</span>; in2 = runLength</span><br><span class="line">   <span class="keyword">while</span> (in1 &lt; N) &#123;</span><br><span class="line">      seek to position in1 in inf1</span><br><span class="line">      end1 = in1+runLength</span><br><span class="line">      it1 = getItem(inf1)</span><br><span class="line">      seek to position in2 in inf2</span><br><span class="line">      end2 = in2+runLength</span><br><span class="line">      it2 = getItem(inf2)</span><br><span class="line">      <span class="keyword">while</span> (in1 &lt; end1 &amp;&amp; in2 &lt; end2) &#123;</span><br><span class="line">         <span class="keyword">if</span> (less(it1,it2)) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            write it2 to outf</span><br><span class="line">            it2 = getItem(inf2); in2++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">while</span> (in1 &lt; end1) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">while</span> (in2 &lt; end2) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">        &#125;</span><br><span class="line">        in1 += runLength; in2 += runLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h3><p>We can create a heap, and repeatedly insert and remove from a heap, which is $O(2n\log n)=O(n \log n)$</p>
<h3 id="Comparison-between-Mergesort-and-Quicksort"><a href="#Comparison-between-Mergesort-and-Quicksort" class="headerlink" title="Comparison between Mergesort and Quicksort"></a>Comparison between Mergesort and Quicksort</h3><p>Why quicksort is better than mergesort?<br>There are certain reasons due to which quicksort is better especially in case of arrays:</p>
<ol>
<li><strong>Auxiliary Space</strong>: Mergesort uses extra space, quicksort requires little space and exhibits good cache locality.(in-place sorting)</li>
<li><strong>Worst Cases</strong>: The worst case of quicksort $O(n^2)$ can be avoided by using randomized quicksort. It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort.</li>
<li><strong>Locality of reference</strong> : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment.</li>
<li><strong>Merge sort is better for large data structures</strong>: Mergesort is a stable sort (unlike quicksort and heapsort) and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media.</li>
</ol>
<h2 id="Summary-of-Comparison-Based-Sorting"><a href="#Summary-of-Comparison-Based-Sorting" class="headerlink" title="Summary of Comparison-Based Sorting"></a>Summary of Comparison-Based Sorting</h2><ul>
<li>Selection sort:<ul>
<li>stability depends on implementation</li>
<li>not adaptive</li>
</ul>
</li>
<li>Bubble sort:<ul>
<li>stable if items don’t move past same-key items</li>
<li>adaptive if it terminates when no swaps</li>
</ul>
</li>
<li>Insertion sort:<ul>
<li>stability depends on implementation of insertion</li>
<li>adaptive if it stops scan when position is found</li>
</ul>
</li>
<li>Quicksort:<ul>
<li>easy to make stable on lists; difficult on arrays</li>
<li>can be adaptive depending on implementation</li>
</ul>
</li>
<li>Merge sort:<ul>
<li>is stable if merge oeration is stable</li>
<li>can be made adaptive (but above version is not)</li>
</ul>
</li>
</ul>
<h3 id="Sorting-Lower-Bound-for-Comparison-Based-Sorting"><a href="#Sorting-Lower-Bound-for-Comparison-Based-Sorting" class="headerlink" title="Sorting Lower Bound for Comparison-Based Sorting"></a>Sorting Lower Bound for Comparison-Based Sorting</h3><p>Many popular sorting algorithms “compare” pairs of keys (objects) to sort an input sequence.</p>
<p>Lower Bound: Any comparison-based sorting algorithm must take Ω (n log n) time to sort n elements in the worst case.</p>
<p>Given $n$ elements (no duplicates),</p>
<ul>
<li>there are $n!$ possible permutation sequences</li>
<li>one of these possible sequences is a sorted sequence</li>
<li>each comparision reduces number of possible sequences to be considered</li>
</ul>
<p><img src="media/15541784881323/15547866806568.png" alt=""></p>
<p>For a given input,</p>
<ul>
<li>the algorithm follows a path from the root to a leaf</li>
<li>requires one comparison at each level</li>
<li>there are $n!$ leaves for $n$ elements</li>
<li>height of such tree is at least $\log_2(n!)$, so number of comparisions required is at least $log_2(n!)$</li>
</ul>
<p>$$\log_2(n!) = \log_2(1) + \log_2(2) + … + \log_2(n/2) + … + \log_2(n-1) + \log_2(n)<br>\ \log_2(n!) &gt;=  \log_2(n/2) + … + \log_2(n-1) + \log_2(n)<br>\ \log_2(n!) &gt;=  (n/2)\log_2(n/2)<br>\ \log_2(n!) =  Ω (n \log_2 n)$$</p>
<p>==Therefore, for any comparison-based sorting algorithm, the lower bound is $Ω (n \log_2 n)$.==</p>
<h2 id="Non-comparison-based-Sorting-Algo"><a href="#Non-comparison-based-Sorting-Algo" class="headerlink" title="Non comparison-based Sorting Algo"></a>Non comparison-based Sorting Algo</h2><h3 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h3><p>Radix sort is a non-comparative sorting algorithm.</p>
<p>Radix sort basic idea:</p>
<ul>
<li>represent key as a tuple $(k_1, k_2, …, k_m)$</li>
<li>finite and normally few possible values of $k_i$</li>
<li><p>sorting algorithm:</p>
<ul>
<li><strong>stable</strong> sort on $k_m$,</li>
<li>then <strong>stable</strong> sort on $k_{(m-1)}$,</li>
<li>similarly continue until $k_1$</li>
</ul>
<p><img src="media/15541784881323/15547874455855.png" alt=""></p>
</li>
</ul>
<p>Time complexity:</p>
<ul>
<li>stable sort like bucket/pigeonhole sort runs in time $O(n)$</li>
<li>radix sort runs in time $O(mn)$ , where $m$ is number of sub-keys ($k_i$ in a tuple above)</li>
<li>radix sort performs better (==for sufficiently large $n$==) than the best comparison-based sorting algorithms</li>
</ul>
<h3 id="Bucket-Pigeonhole-Sort"><a href="#Bucket-Pigeonhole-Sort" class="headerlink" title="Bucket/Pigeonhole Sort"></a>Bucket/Pigeonhole Sort</h3><p>Bucket sort is a common way for the stable sorting in the radix sort.</p>
<p>Bucket/Pigeonhole sort basic idea:</p>
<ul>
<li>finite and normally few possible values of keys, for example<ul>
<li>numeric: 0 to 9</li>
<li>week days: monday, tuesday, wednesday, thursday, friday, saturday, sunday</li>
<li>months: january to december</li>
</ul>
</li>
<li>each key value maps to an index into the array of buckets/pigeonholes</li>
<li>one bucket (pigeonhole) per key value</li>
<li>sorting algorithm:<ul>
<li>phase-1: move each entry from the input sequence to the corresponding bucket (say queue) in the array of buckets</li>
<li>phase-2: move entries of each bucket, in the required order, to the end of the output sequence</li>
</ul>
</li>
</ul>
<p>Time complexity: bucket sort runs in time $O(n)$, assuming number of buckets is not large.</p>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/03/25/Hashing Algo/" rel="next" title="">
                <i class="fa fa-chevron-left"></i> 
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/04/15/Text Processing Algo/" rel="prev" title="">
                 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Han">
            
              <p class="site-author-name" itemprop="name">Han</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hangary" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:HangaryLiu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Sorting-Algo"><span class="nav-number">1.</span> <span class="nav-text">Sorting Algo</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Elementary-Sorting-Algo"><span class="nav-number">1.1.</span> <span class="nav-text">Elementary Sorting Algo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Selection-Sort-Simple-non-adaptive-method"><span class="nav-number">1.1.1.</span> <span class="nav-text">Selection Sort: Simple non-adaptive method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bubble-Sort-Simple-adaptive-method"><span class="nav-number">1.1.2.</span> <span class="nav-text">Bubble Sort: Simple adaptive method</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Insertion-Sort-Simple-adaptive-method"><span class="nav-number">1.1.3.</span> <span class="nav-text">Insertion Sort: Simple adaptive method</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Inversions-and-Partially-sorted-Array"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">Inversions and Partially sorted Array</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Shell-Sort-Improving-Insertion-Sort"><span class="nav-number">1.1.4.</span> <span class="nav-text">Shell Sort: Improving Insertion Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Summary-of-elementary-sorting-Algo"><span class="nav-number">1.1.5.</span> <span class="nav-text">Summary of elementary sorting Algo</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Advanced-Sorting-Algo"><span class="nav-number">1.2.</span> <span class="nav-text">Advanced Sorting Algo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Quick-Sort"><span class="nav-number">1.2.1.</span> <span class="nav-text">Quick Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Vanilla-Quick-Sort"><span class="nav-number">1.2.1.1.</span> <span class="nav-text">Vanilla Quick Sort</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Improved-Qucik-Sort"><span class="nav-number">1.2.1.2.</span> <span class="nav-text">Improved Qucik Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#Handle-max-min-pivot-Median-of-three"><span class="nav-number">1.2.1.2.1.</span> <span class="nav-text">Handle max/min pivot: Median-of-three</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handle-small-partitions-differently"><span class="nav-number">1.2.1.2.2.</span> <span class="nav-text">Handle small partitions differently</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#Handle-Duplicate-keys-Three-way-partitioning"><span class="nav-number">1.2.1.2.3.</span> <span class="nav-text">Handle Duplicate keys: Three-way partitioning</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Non-recursive-Quicksort"><span class="nav-number">1.2.1.3.</span> <span class="nav-text">Non-recursive Quicksort</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Merge-Sort"><span class="nav-number">1.2.2.</span> <span class="nav-text">Merge Sort</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Non-recursive-Mergesort-Bottom-up-mergesort"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">Non-recursive Mergesort: Bottom-up mergesort ?</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Mergesort-Variation"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">Mergesort Variation</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#External-Merge-Sort"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">External Merge Sort</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Heap-Sort"><span class="nav-number">1.2.3.</span> <span class="nav-text">Heap Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Comparison-between-Mergesort-and-Quicksort"><span class="nav-number">1.2.4.</span> <span class="nav-text">Comparison between Mergesort and Quicksort</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Summary-of-Comparison-Based-Sorting"><span class="nav-number">1.3.</span> <span class="nav-text">Summary of Comparison-Based Sorting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Sorting-Lower-Bound-for-Comparison-Based-Sorting"><span class="nav-number">1.3.1.</span> <span class="nav-text">Sorting Lower Bound for Comparison-Based Sorting</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Non-comparison-based-Sorting-Algo"><span class="nav-number">1.4.</span> <span class="nav-text">Non comparison-based Sorting Algo</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Radix-Sort"><span class="nav-number">1.4.1.</span> <span class="nav-text">Radix Sort</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Bucket-Pigeonhole-Sort"><span class="nav-number">1.4.2.</span> <span class="nav-text">Bucket/Pigeonhole Sort</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
