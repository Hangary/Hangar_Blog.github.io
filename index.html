<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay Hungry, Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="Hangary Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hangary Blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hangary Blog">
<meta name="twitter:description" content="Stay Hungry, Stay Foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":true,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hangary Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hangary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br>
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/25/Python 与 Flask 中的上下文（下）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/25/Python 与 Flask 中的上下文（下）/" itemprop="url">Python 与 Flask 中的上下文（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-25T00:00:00-05:00">
                2020-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Python-与-Flask-中的上下文（下）"><a href="#Python-与-Flask-中的上下文（下）" class="headerlink" title="Python 与 Flask 中的上下文（下）"></a>Python 与 Flask 中的上下文（下）</h1><blockquote>
<p>最近在学习 <code>Flask</code>，其中 <strong>上下文 Context</strong> 是 <code>Flask</code> 中非常重要的一个概念，而  <code>Python</code> 中也存在一个 <strong>上下文管理器 Context Manager</strong> 机制。所以这里稍微整理一下相关的概念。</p>
</blockquote>
<p>Flask 中，视图函数所需要的信息对象传递是通过类似 <em>全局变量</em> 的方式实现的，即上下文。</p>
<p>Flask 中的两类上下文：</p>
<ol>
<li><strong>应用上下文 Application Context</strong><ul>
<li><code>current_app</code>： 当前激活程序的程序实例，用于存储应用程序中的配置变量。</li>
<li><code>g</code>：处理请求时用作<u>临时存储</u>的对象，每次请求都会重设这个变量。</li>
</ul>
</li>
<li><strong>请求上下文 Request Context</strong>: 每次 HTTP Request 发生时，WSGI server(比如gunicorn)调Flask.<strong>call</strong>()之后，在Flask对象内部创建的Request对象；<ul>
<li><code>request</code>：请求对象，封装了 HTTP 请求（<code>environ</code>）的内容。</li>
<li><code>session</code>：记录了请求会话中的用户信息，根据 cookie 实现。</li>
</ul>
</li>
</ol>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/25/Python 与 Flask 中的上下文（下）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/03/10/Python 与 Flask 中的上下文（上）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/03/10/Python 与 Flask 中的上下文（上）/" itemprop="url">Python 与 Flask 中的上下文（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-10T00:00:00-05:00">
                2020-03-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Python-与-Flask-中的上下文（上）"><a href="#Python-与-Flask-中的上下文（上）" class="headerlink" title="Python 与 Flask 中的上下文（上）"></a>Python 与 Flask 中的上下文（上）</h1><blockquote>
<p>最近在学习 <code>Flask</code>，其中 <strong>上下文 Context</strong> 是 <code>Flask</code> 中非常重要的一个概念，而  <code>Python</code> 中也存在一个 <strong>上下文管理器 Context Manager</strong> 机制。所以这里稍微整理一下相关的概念。</p>
</blockquote>
<h2 id="什么是-上下文-Context"><a href="#什么是-上下文-Context" class="headerlink" title="什么是 上下文 Context"></a>什么是 上下文 Context</h2><p>在计算机术语中，<strong>上下文 Context</strong> 是一个很广泛的术语，在不同领域往往有不同的含义。我自己的理解是，在编程中，上下文可以理解为一个操作执行时需要的特定的执行<strong>环境 environment</strong>。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/03/10/Python 与 Flask 中的上下文（上）/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/02/01/Python 装饰器梳理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/02/01/Python 装饰器梳理/" itemprop="url">Python 装饰器梳理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-02-01T00:00:00-06:00">
                2020-02-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Python-装饰器梳理"><a href="#Python-装饰器梳理" class="headerlink" title="Python 装饰器梳理"></a>Python 装饰器梳理</h1><p>Python 中，<strong>装饰器 decorator</strong> 是一个接受一个原函数，并返回一个新函数的 <code>Callable</code> 对象，其类型符合 <code>decorator: function -&gt; Callable</code>。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/02/01/Python 装饰器梳理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/01/20/Python 从生成器到协程/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2020/01/20/Python 从生成器到协程/" itemprop="url">Python 从生成器到协程</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-01-20T00:00:00-06:00">
                2020-01-20
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Python-从生成器到协程"><a href="#Python-从生成器到协程" class="headerlink" title="Python 从生成器到协程"></a>Python 从生成器到协程</h1><p>在开始之前，首先需要明白一个 Python 重要的概念：<strong>全局解释器锁 GIL</strong>， 即在同一时刻只能有一条线程正在运行。这一机制使得 Python 多线程程序并不能利用多核 CPU 的优势。所以说 Python 的多线程适用于 I/O 密集型程序，而非计算密集型程序。</p>
<p>但是，如果我们用多线程来处理  I/O 密集型程序，尽管可以避免阻塞，但却也会因为频繁切换线程而带来性能损耗，为了解决这一问题，<strong>协程 Coroutine</strong> 就出现了。</p>
<blockquote>
<p>协程是一种用户态的轻量级线程，即协程是由用户程序自己控制调度的。</p>
<p>协程适合 I/O 密集型的任务并发，而不适合 CPU 密集型的任务并发。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2020/01/20/Python 从生成器到协程/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/10/21/Python `else` 语句整理/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/10/21/Python `else` 语句整理/" itemprop="url">Python `else` 语句整理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-10-21T00:00:00-05:00">
                2019-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="Python-else-语句整理"><a href="#Python-else-语句整理" class="headerlink" title="Python else 语句整理"></a>Python <code>else</code> 语句整理</h1><p> Python 中 <code>else</code> 语句不仅可以和 <code>if</code> 搭配，还可以和 <code>for</code> \ <code>while</code> \ <code>try</code> 这三种结构一起使用：</p>
<ul>
<li><code>for</code> \ <code>while</code>：<code>else</code>  区块仅会在循环区块<em><u>完整</u></em>结束后运行。即如果 <code>for</code> \ <code>while</code> 循环中途被 <code>break</code> 打断，那么 <code>else</code> 语句便不会执行。</li>
<li><code>try</code>：<code>else</code>  区块仅会在 <code>try</code> 区块<em><u>完整</u></em>结束后运行。即如果 <code>try</code> 区块中抛出异常，那么 <code>else</code> 语句便不会执行。</li>
<li>同时，如果抛出异常或者 <code>return</code> \ <code>break</code> \ <code>continue</code> 使得控制流跳出 <code>else</code> 所在区块，那么 <code>else</code> 也不会被执行。</li>
</ul>
<blockquote>
<p>实际上，<code>else</code> 这个关键词在这里并不是一个好选择，因为 <code>else</code> 在这里的真正意思是：如果成功完成上一个区块，那么就运行这个区块。个人认为 <code>then</code> 会是一个更好的选择。</p>
</blockquote>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/10/21/Python `else` 语句整理/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/从 Functor 到 Applicative 再到 Monad/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/从 Functor 到 Applicative 再到 Monad/" itemprop="url">从 Functor 到 Applicative 再到 Monad</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T00:00:00-05:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          <h1 id="从-Functor-到-Applicative-再到-Monad"><a href="#从-Functor-到-Applicative-再到-Monad" class="headerlink" title="从 Functor 到 Applicative 再到 Monad"></a>从 Functor 到 Applicative 再到 Monad</h1><blockquote>
<p>本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。</p>
</blockquote>
<p>大多数 Monad 尝试解决的是 <strong>副作用 (side effect)</strong> 的问题。</p>
<p>在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 <code>print</code>）或者修改指针中的值。<br>但是，在纯函数式编程中，一个函数只能接收输入、返回输出。</p>
          <!--noindex-->
          <div class="post-button text-center">
            <a class="btn" href="/2019/06/26/从 Functor 到 Applicative 再到 Monad/#more" rel="contents">
              阅读全文 &raquo;
            </a>
          </div>
          <!--/noindex-->
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/15/Text Processing Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/15/Text Processing Algo/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-15T03:10:37-05:00">
                2019-04-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Text-Processing-Algo"><a href="#Text-Processing-Algo" class="headerlink" title="Text Processing Algo"></a>Text Processing Algo</h1><p>算法的本质：<br>在某些特定的 assumptions 下，我们可以得到比 brute-force 更快的表现。</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>A <strong><em>string</em></strong> is a sequence of characters.</p>
<p>An <strong><em>alphabet</em></strong> $Σ$ is the set of possible characters in strings.</p>
<p>Notation:</p>
<ul>
<li>$length(P)$ … #characters in P</li>
<li>$λ$ … empty string  ($length(λ) = 0$)</li>
<li>$Σ^m$ … set of all strings of length m over alphabet $Σ$</li>
<li>$Σ^*$ … set of all strings over alphabet $Σ$</li>
</ul>
<p><strong><em>Substring</em></strong> of $P$: any string Q such that P = νQω, for some $ν,ω∈Σ^*$</p>
<ul>
<li><strong><em>prefix</em></strong> of $P$: any string Q such that P = Qω, for some $ω∈Σ^*$</li>
<li><strong><em>suffix</em></strong> of $P$: any string Q such that P = ωQ, for some $ω∈Σ^*$</li>
<li>Note: substring can be empty string or $P$</li>
</ul>
<p>In C a string is an array of chars containing ASCII codes.</p>
<ul>
<li>these arrays have an extra element containing a 0</li>
<li>the extra 0 can also be written ‘\0’   (null character or null-terminator)</li>
<li>convenient because don’t have to track the length of the string</li>
</ul>
<h2 id="Pattern-Matching"><a href="#Pattern-Matching" class="headerlink" title="Pattern Matching"></a>Pattern Matching</h2><p>Normally, we have pattern checked <strong>*backwards</strong>.</p>
<p><img src="media/15553158370925/15553167075070.png" alt="-w250"></p>
<p>Performance of brute-force algo: $O(m\times n)$</p>
<h3 id="Boyer-Moore-Algorithm"><a href="#Boyer-Moore-Algorithm" class="headerlink" title="Boyer-Moore Algorithm"></a>Boyer-Moore Algorithm</h3><p>The Boyer-Moore pattern matching algorithm is based on two heuristics:</p>
<ul>
<li><strong>Looking-glass heuristic</strong>: Compare <code>P</code> with subsequence of <code>T</code> moving <em>backwards</em></li>
<li><strong>Character-jump heuristic</strong>: When a mismatch occurs at <code>T[i] = c</code><ul>
<li>==<strong>Small jump</strong>==: if <code>P</code> contains <code>c</code><ul>
<li>shift <code>P</code> so as to align the last occurrence of <code>c</code> in <code>P</code> with <code>T[i]</code></li>
<li>or move forward 1 character, if this shift need a backward move</li>
</ul>
</li>
<li>==<strong>Big jump</strong>==: otherwise shift <code>P</code> so as to align <code>P[0]</code> with <code>T[i+1]</code></li>
</ul>
</li>
</ul>
<p>Example:<br><img src="media/15553158370925/15553173397192.png" alt=""></p>
<ol>
<li>Compare <code>m</code> and <code>t</code>, <code>m != t</code> and <code>rithm</code> contains <code>t</code>, small jump to make the <code>t</code> align with the position <code>t</code> in <code>rithm</code></li>
<li>Compare <code>m</code> and <code>e</code>, <code>m != e</code> and P not contains <code>e</code>, big jump</li>
<li>…</li>
</ol>
<h4 id="Last-occurrence-function"><a href="#Last-occurrence-function" class="headerlink" title="Last-occurrence function"></a>Last-occurrence function</h4><p>Boyer-Moore algorithm <u>preprocesses</u> pattern P and alphabet Σ to build the <strong><em>last-occurrence function</em></strong> $L$. This functions map a character to its last occurred index in the pattern.</p>
<p>$L$ maps $Σ$ to integers such that $L(c)$ is defined as</p>
<ul>
<li>the largest index $i$ such that $P[i]=c$, or</li>
<li>$-1$ if no such index exists</li>
</ul>
<p><img src="media/15553158370925/15553177234159.jpg" alt="-w300"></p>
<p>Suppose we have a mismatch at <code>T[i]</code> and <code>P[j]</code> (i.e. <code>T[i]</code> != <code>P[j]</code>)<br>if <code>L(T[i]) = m</code>:</p>
<ul>
<li>if <code>m</code> != -1, align <code>P[m]</code> with <code>T[i]</code></li>
<li>if <code>m</code> == -1, big jump</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BoyerMooreMatch(T,P,Σ):</span><br><span class="line">|  Input  text T of length n, pattern P of length m, alphabet Σ</span><br><span class="line">|  Output starting index of a substring of T equal to P</span><br><span class="line">|         -1 if no such substring exists</span><br><span class="line">|</span><br><span class="line">|  L=lastOccurenceFunction(P,Σ)</span><br><span class="line">|  i=m-1, j=m-1                 // start at end of pattern</span><br><span class="line">|  repeat</span><br><span class="line">|  |  if T[i]=P[j] then</span><br><span class="line">|  |     if j=0 then</span><br><span class="line">|  |        return i            // match found at i</span><br><span class="line">|  |     else</span><br><span class="line">|  |        i=i-1, j=j-1</span><br><span class="line">|  |     end if</span><br><span class="line">|  |  else                      // character-jump</span><br><span class="line">|  |     i=i+m-min(j,1+L[T[i]])     // choose the smaller distance to jump</span><br><span class="line">|  |     j=m-1</span><br><span class="line">|  |  end if</span><br><span class="line">|  until i≥n</span><br><span class="line">|  return -1                    // no match</span><br></pre></td></tr></table></figure>
<p><img src="media/15553158370925/15553191312556.png" alt="-w500"></p>
<h3 id="Knuth-Morris-Pratt-Algorithm"><a href="#Knuth-Morris-Pratt-Algorithm" class="headerlink" title="Knuth-Morris-Pratt Algorithm"></a>Knuth-Morris-Pratt Algorithm</h3><p>The Knuth-Morris-Pratt algorithm</p>
<ul>
<li>compares the pattern to the text left-to-right</li>
<li>but shifts the pattern more intelligently than the brute-force algorithm</li>
</ul>
<p>==This is useful for text with small alphabet Σ (with repeated characters and suffix).==</p>
<p><img src="media/15553158370925/15553192047725.png" alt="-w500"></p>
<p>KMP preprocesses the pattern to find matches of its prefixes with itself</p>
<ul>
<li><strong><em>Failure function</em></strong> $F(j)$ defined as the <u>size/length</u> of the largest prefix of <code>P[0..j]</code> that is also a suffix of <code>P[1..j]</code></li>
<li>if mismatch occurs at Pj   ⇒ advance j to F(j-1)</li>
</ul>
<p>Difference between Last-occurrence function and Failure function: </p>
<ol>
<li>Last-occurrence function map characters to an <strong>index</strong>, while Failure function map characters to a <strong>length</strong>.</li>
<li>Last-occurrence function has <code>-1</code>, while Failure function has <code>0</code>.</li>
</ol>
<p>But these 2 functions have same purpose: tell the pattern how to move its pointer to and align the pointer with the <code>T[i]</code>.</p>
<p>If we mismatch <code>T[i]</code> and <code>P[j]</code>, </p>
<ul>
<li>if <code>j &gt; 0</code>, then we calculate <code>F(P[j-1]) = m</code> (<code>j-1</code> is the last matched character), align <code>P[m]</code> with <code>T[i]</code>.</li>
<li>else move forward on the string one character</li>
</ul>
<p><img src="media/15553158370925/15553197144901.jpg" alt="-w250"></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">KMPMatch(T,P):</span><br><span class="line">|  Input  text T of length n, pattern P of length m</span><br><span class="line">|  Output starting index of a substring of T equal to P</span><br><span class="line">|         -1 if no such substring exists</span><br><span class="line">|</span><br><span class="line">|  F=failureFunction(P)</span><br><span class="line">|  i=0, j=0                    // start from left</span><br><span class="line">|  while i&lt;n do</span><br><span class="line">|  |  if T[i]=P[j] then</span><br><span class="line">|  |     if j=m-1 then</span><br><span class="line">|  |        return i-j         // match found at i-j</span><br><span class="line">|  |     else</span><br><span class="line">|  |        i=i+1, j=j+1</span><br><span class="line">|  |     end if</span><br><span class="line">|  |  else                     // mismatch at P[j]</span><br><span class="line">|  |     if j&gt;0 then</span><br><span class="line">|  |        j=F[j-1]           // resume comparing P at F[j-1]</span><br><span class="line">|  |     else</span><br><span class="line">|  |        i=i+1</span><br><span class="line">|  |     end if</span><br><span class="line">|  |  end if</span><br><span class="line">|  end while</span><br><span class="line">|  return -1                   // no match</span><br><span class="line"></span><br><span class="line">// failure function: get the position of last previous match for every character</span><br><span class="line">failureFunction(P):</span><br><span class="line">|  Input  pattern P of length m</span><br><span class="line">|  Output failure function for P</span><br><span class="line">|</span><br><span class="line">|  F[0]=0</span><br><span class="line">|  i=1, j=0</span><br><span class="line">|  while i&lt;m do</span><br><span class="line">|  |  if P[i]=P[j] then   // we have matched j+1 characters, j+1 would be the length of already matched characters</span><br><span class="line">|  |     F[i]=j+1</span><br><span class="line">|  |     i=i+1, j=j+1</span><br><span class="line">|  |  else if j&gt;0 then    // use failure function to shift P</span><br><span class="line">|  |     j=F[j-1]</span><br><span class="line">|  |  else</span><br><span class="line">|  |     F[i]=0           // no match</span><br><span class="line">|  |     i=i+1</span><br><span class="line">|  |  end if</span><br><span class="line">|  end while</span><br><span class="line">|  return F</span><br></pre></td></tr></table></figure>
<p>Performance: $O(m+n)$</p>
<h2 id="Trie"><a href="#Trie" class="headerlink" title="Trie"></a>Trie</h2><p>A trie is a compact data structure for representing a set of strings, which supports pattern matching queries in time proportional to the pattern size.</p>
<p><strong><em>Tries</em></strong> are trees organised using parts of keys (rather than whole keys).</p>
<p><img src="media/15553158370925/15553212496975.png" alt=""></p>
<p>Each node in a trie</p>
<ul>
<li>contains one part of a key<ul>
<li>Compressed tries: one character</li>
<li>Suffix tries: one suffix</li>
</ul>
</li>
<li>may have up to 26 children</li>
<li>may be tagged as ==<strong><em>a “finishing” node</em></strong>== (red nodes in the example diagram)</li>
<li>but even “finishing” nodes may have children<br>Depth $d$ of trie = length of longest key value<br>Cost of searching $O(d)$   (independent of $n$)</li>
</ul>
<p>Basic operations on tries:</p>
<ol>
<li>search for a key</li>
<li>insert a key</li>
</ol>
<p>Performance of standard tries:</p>
<ul>
<li>$O(n)$ space</li>
<li>insertion and search in time $O(d·m)$</li>
</ul>
<h3 id="Compressed-Tries"><a href="#Compressed-Tries" class="headerlink" title="Compressed Tries"></a>Compressed Tries</h3><p>Compressed tries</p>
<ul>
<li>have internal nodes of degree ≥ 2</li>
<li>are obtained from standard tries by compressing “redundant” chains of nodes (which have only 1 child)</li>
</ul>
<p><img src="media/15553158370925/15553890988364.png" alt="-w500"></p>
<h4 id="Suffix-Tries"><a href="#Suffix-Tries" class="headerlink" title="Suffix Tries"></a>Suffix Tries</h4><p>The suffix trie of a text <code>T</code> is the compressed trie of all the suffixes of <code>T</code>.</p>
<p><img src="media/15553158370925/15553891401177.png" alt="-w500"></p>
<h2 id="Text-Compression"><a href="#Text-Compression" class="headerlink" title="Text Compression"></a>Text Compression</h2><p>Problem: Efficiently encode a given string X by a smaller string Y</p>
<h3 id="Huffman’s-algorithm"><a href="#Huffman’s-algorithm" class="headerlink" title="Huffman’s algorithm"></a>Huffman’s algorithm</h3><ul>
<li>computes frequency f(c) for each character c</li>
<li>encodes high-frequency characters with short code</li>
<li>no code word is a prefix of another code word</li>
<li>uses optimal encoding tree to determine the code words</li>
</ul>
<p><strong>Code:</strong> mapping of each character to a binary code word</p>
<p>==<strong>Prefix code</strong>: binary code such that no code word is prefix of another code word.== (otherwise, it is impossible to uncode a string)</p>
<p><strong><em>Encoding tree</em></strong>:</p>
<ul>
<li>represents a <u>prefix code</u></li>
<li>each leaf stores a character</li>
<li>code word given by the path from the root to the leaf ==(<code>0</code> for <strong>left child</strong>, <code>1</code> for <strong>right child</strong>)==</li>
</ul>
<p><img src="media/15553158370925/15553906767461.png" alt="-w500"></p>
<p>How to build an encoding tree:</p>
<ul>
<li>computes <strong>frequency</strong> f(c) for each character</li>
<li>==successively combines pairs of lowest-frequency characters to build encoding tree “bottom-up”== (make sure more frequent characters have less depth, which is equal to the length of its code)</li>
</ul>
<p><img src="media/15553158370925/15553920243497.png" alt="-w500"></p>
<ul>
<li>The numbers in the green nodes stand for the total frequency of their children</li>
<li>All the leaves stand for a character. And parent nodes cannot be a character (<em>Prefix code</em>).</li>
</ul>
<p>Huffman’s algorithm for build an encoding tree by using <strong>priority queue</strong>:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">HuffmanCode(T):</span><br><span class="line">|  Input  string T of size n</span><br><span class="line">|  Output optimal encoding tree for T</span><br><span class="line">|</span><br><span class="line">|  compute frequency array</span><br><span class="line">|  Q=new priority queue</span><br><span class="line">|  for all characters c do</span><br><span class="line">|     T=new single-node tree storing c</span><br><span class="line">|     join(Q,T) with frequency(c) as key</span><br><span class="line">|  end for</span><br><span class="line">|  while |Q|≥2 do</span><br><span class="line">|     f1=Q.minKey(), T1=leave(Q)</span><br><span class="line">|     f2=Q.minKey(), T2=leave(Q)</span><br><span class="line">|     T=new tree node with subtrees T1 and T2</span><br><span class="line">|     join(Q,T) with f1+f2 as key </span><br><span class="line">|  end while</span><br><span class="line">|  return leave(Q)</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/01/Sorting Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/04/01/Sorting Algo/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-04-01T23:14:48-05:00">
                2019-04-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Sorting-Algo"><a href="#Sorting-Algo" class="headerlink" title="Sorting Algo"></a>Sorting Algo</h1><p>Sorting involves arranging a collection of items in order</p>
<ul>
<li>based on some property of the item (e.g. key)</li>
<li>using an ordering relation on that property</li>
</ul>
<p>Why is sorting useful?</p>
<ul>
<li>speeds up subsequent searching (binary searching need a sorted list)</li>
<li>arranges data in a human-useful way (e.g. list of students in a tutor class, ordered by family-name or id)</li>
<li>provides intermediate step for advanced algorithms (e.g. duplicate detection/removal, many DBMS operations)</li>
</ul>
<p>Properties of sorting algorithms: <em>stable</em>, <em>adaptive</em>, <em>in-place</em></p>
<ul>
<li><strong><em>Stable</em></strong>: if two items have duplicate keys, their relative order would not change in the sorted array. <ul>
<li>let $x = a[i]$, $y = a[j]$, $key(x) == key(y)$, if $x$ precedes $y$ in $a$, then $x$ precedes $y$ in $a’$</li>
<li>This is particularly useful to repeated sorting different keys for an array.</li>
</ul>
</li>
<li><strong><em>Adaptive</em></strong>: whether it takes advantage of existing order in its input<ul>
<li>behaviour/performance of algorithm affected by data values</li>
<li>i.e. <u>best/average/worst case performance differs</u></li>
<li>e.g. bubble sort</li>
</ul>
</li>
<li><strong><em>In-place sorting</em></strong>: no additional storage space is needed to perform sorting.<ul>
<li>Accordingly, <strong><em>out-place sorting</em></strong> needs to create a copy of array to create a new array.</li>
</ul>
</li>
<li><strong><em>Comparison-based sorting</em></strong>: A comparison sort is a type of sorting algorithm that only reads the list elements through a single abstract <strong>comparison</strong> operation (often a “less than or equal to” operator or a three-way comparison) that determines which of two elements should occur first in the final sorted list. </li>
</ul>
<p>Why stable is important:</p>
<blockquote>
<p>Suppose we have a list of first and last names. We are asked to sort “by last name, then by first”. We could first sort (stable or unstable) by the first name, then stable sort by the last name. After these sorts, the list is primarily sorted by the last name. However, where last names are the same, the first names are sorted.</p>
</blockquote>
<p>Some other properties:</p>
<p>Two major classes of sorting algo: $O(n^2)$, $O(n \log n)$</p>
<ul>
<li>$O(n^2)$ are acceptable if $n$ is small (hundreds)</li>
</ul>
<p>Basic framework for Sorting:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// we deal with generic Items</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Item;</span><br><span class="line"></span><br><span class="line"><span class="comment">// abstractions to hide details of Items</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> key(A) (A)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> less(A,B) (key(A) &lt; key(B))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swap(A,B) &#123;Item t; t = A; A = B; B = t;&#125;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> swil(A,B) &#123;<span class="meta-keyword">if</span> (less(A,B)) swap(A,B);&#125;</span></span><br><span class="line"><span class="comment">// swil = SWap If Less</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Sorts a slice of an array of Items</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check for sortedness (to validate functions)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">isSorted</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span>;</span><br></pre></td></tr></table></figure>
<p>Two key sorting abstractions:</p>
<ul>
<li><code>Compare</code>: whether item <code>v</code> is less than <code>w</code></li>
<li><code>Swap</code>: swap item <code>v</code> and <code>w</code> in array <code>a[]</code></li>
</ul>
<h2 id="Elementary-Sorting-Algo"><a href="#Elementary-Sorting-Algo" class="headerlink" title="Elementary Sorting Algo"></a>Elementary Sorting Algo</h2><p>To describe simple sorting, we use diagrams like:<img src="media/15541784881323/15550378379676.png" alt="-w600"></p>
<p>In these algorithms:</p>
<ul>
<li>a <strong><em>segment</em></strong> of the array is already sorted, which we do not need to consider any more</li>
<li>each <strong><em>iteration</em></strong> makes more of the array sorted</li>
</ul>
<p>Performance of elementary: $O(n^k)$ where $k &gt; 1$</p>
<h3 id="Selection-Sort-Simple-non-adaptive-method"><a href="#Selection-Sort-Simple-non-adaptive-method" class="headerlink" title="Selection Sort: Simple non-adaptive method"></a>Selection Sort: Simple non-adaptive method</h3><p>Basic Idea:<br>For every iteration:</p>
<ol>
<li>find the smallest element in the <em>unsorted segment</em>, put it into the last slot of the <em>sorted segment</em></li>
<li>repeat until all elements are in the sorted segment</li>
</ol>
<p><img src="media/15541784881323/15550378979174.png" alt="-w500"></p>
<p>Performance: $O(n^2)$, not adaptive</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, min;</span><br><span class="line">   <span class="keyword">for</span> (i = lo; i &lt; hi<span class="number">-1</span>; i++) &#123;</span><br><span class="line">      min = i;</span><br><span class="line">      <span class="keyword">for</span> (j = i+<span class="number">1</span>; j &lt;= hi; j++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (less(a[j],a[min])) min = j;</span><br><span class="line">      &#125;</span><br><span class="line">      swap(a[i], a[min]);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Bubble-Sort-Simple-adaptive-method"><a href="#Bubble-Sort-Simple-adaptive-method" class="headerlink" title="Bubble Sort: Simple adaptive method"></a>Bubble Sort: Simple adaptive method</h3><p>Simple adaptive method:<br>For every iteration:</p>
<ul>
<li>elements move until they meet a smaller element, eventually <code>i</code>th smallest element moves to <code>i</code>th position<ul>
<li>those small elements are in the sorted segment</li>
</ul>
</li>
<li>repeat until there are no swaps during one iteration (already completely sorted)</li>
</ul>
<p>==This idea is basically same as the insertion sort (move smaller elements to the sorted segment), but the advantage is that bubble sort could jump some already sorted elements.==</p>
<p><img src="media/15541784881323/15558964076378.png" alt="-w500"></p>
<p><img src="media/15541784881323/15550379735229.png" alt="-w500"></p>
<p>Performance: </p>
<ul>
<li>best case: $O(n)$, the array is already sorted</li>
<li>worst case: $O(n^2)$, the array is <u>reverse sorted</u></li>
</ul>
<h3 id="Insertion-Sort-Simple-adaptive-method"><a href="#Insertion-Sort-Simple-adaptive-method" class="headerlink" title="Insertion Sort: Simple adaptive method"></a>Insertion Sort: Simple adaptive method</h3><p>Basic ideas: </p>
<ul>
<li>First, take first element and treat as sorted segment (length 1).</li>
<li>Then, for every iteration:<ul>
<li>insert the first element in the <em>unsorted segment</em> into <u>the correct position</u> in the <em>sorted segment</em></li>
<li>repeat until whole array is sorted</li>
</ul>
</li>
</ul>
<p>Steps:<br>Iterate from <code>0</code> to <code>N-1</code>, totally <code>N</code> runs</p>
<ol>
<li>In iteration <code>i</code>, swap <code>a[i]</code> with each larger entry to its left</li>
<li>Continually compare and swap, until it is smaller than its left</li>
<li>Move <code>i</code> to <code>i+1</code>, repeat</li>
</ol>
<p>==Insertion sort is like the combination of reverse bubble sort and selection sort, where you use bubble in the sorted segment.==</p>
<p><img src="media/15541784881323/15559006636164.png" alt="-w500"></p>
<p>Performance:</p>
<ul>
<li>Key operations: For a randomly-ordered array with distinct keys, insertion sort uses $\dfrac{N^2}{4}$ compares and $\dfrac{N^2}{4}$ exchanges on average</li>
<li>best case: $O(n)$, the list is already sorted</li>
<li>worst case: $O(n^2)$, the list is <u>reverse sorted</u></li>
<li>==Note: The advantage that insertion sort has over bubble sort is that, when the list is <u>mostly sorted</u>, bubble sort still need to <strong><em>swap</em></strong> many times, while insertion sort can jump most of those compares and <strong><em>insert</em></strong> directly.==</li>
</ul>
<p>Insertion sort:</p>
<ul>
<li>based on exchanges that only involve adjacent items</li>
<li>already improved above by using moves rather than swaps</li>
<li>“long distance” moves may be more efficient</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, j, val;</span><br><span class="line">   <span class="keyword">for</span> (i = lo+<span class="number">1</span>; i &lt;= hi; i++) &#123;</span><br><span class="line">      val = a[i];</span><br><span class="line">      <span class="keyword">for</span> (j = i; j &gt; lo; j--) &#123;</span><br><span class="line">         <span class="keyword">if</span> (val &gt;= a[j<span class="number">-1</span>]) <span class="keyword">break</span>;</span><br><span class="line">         a[j] = a[j<span class="number">-1</span>];</span><br><span class="line">      &#125;</span><br><span class="line">      a[j] = val;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Inversions-and-Partially-sorted-Array"><a href="#Inversions-and-Partially-sorted-Array" class="headerlink" title="Inversions and Partially sorted Array"></a>Inversions and Partially sorted Array</h4><p>An <strong><em>inversion</em></strong> is a pair of keys that are out of order.</p>
<p><img src="media/15541784881323/15576327661565.jpg" alt="-w600"></p>
<p>An array is <strong><em>partially sorted</em></strong> if the number of inversions is ≤ c N.</p>
<p>==For partially-sorted arrays, insertion sort runs in linear time. The number of exchanges equals the number of inversions.==</p>
<h3 id="Shell-Sort-Improving-Insertion-Sort"><a href="#Shell-Sort-Improving-Insertion-Sort" class="headerlink" title="Shell Sort: Improving Insertion Sort"></a>Shell Sort: Improving Insertion Sort</h3><p>Shell sort is a highly efficient sorting algorithm and is based on insertion sort algorithm. This algorithm avoids large shifts as in case of insertion sort, if the smaller value is to the far right and has to be moved to the far left.</p>
<p>Basic idea:</p>
<ul>
<li>array is <code>h</code>-sorted if taking every <code>h</code>‘th element yields a sorted array<ul>
<li>A 1-sorted array is a completely sorted array.</li>
</ul>
</li>
<li>an <code>h</code>-sorted array is made up of <code>n/h</code> interleaved sorted arrays</li>
</ul>
<p>For every iteration: </p>
<ul>
<li>Insertion sort <code>h</code>-sort array for progressively smaller <code>h</code>, ending with <code>1</code>-sorted.</li>
</ul>
<p>The reason we use Insertion sort for every run:</p>
<ol>
<li>For big <code>h</code>, subarray is small</li>
<li>For small <code>h</code>, subarray is nearly in order (require <strong>adaptability</strong>)</li>
<li>For every <code>h</code>, we need to ensure that the previous sorts remain in order. (require <strong>stability</strong>)</li>
</ol>
<p>Performance: </p>
<ul>
<li>depends on the sequence of <code>h</code> values</li>
<li>not yet been fully analysed</li>
<li>from $O(n^{3/2})$ to $O(n^{4/3})$<ul>
<li>Therefore, it is <strong>very efficient for medium-sized arrays</strong>, though not so useful for large-sized arrays</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> hvals[<span class="number">8</span>] = &#123;<span class="number">701</span>, <span class="number">301</span>, <span class="number">132</span>, <span class="number">57</span>, <span class="number">23</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>&#125;;</span><br><span class="line">   <span class="keyword">int</span> g, h, start, i, j, val;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">for</span> (g = <span class="number">0</span>; g &lt; <span class="number">8</span>; g++) &#123;</span><br><span class="line">      h = hvals[g];</span><br><span class="line">      start = lo + h;</span><br><span class="line">      <span class="keyword">for</span> (i = start; i &lt; hi; i++) &#123;</span><br><span class="line">         val = a[i];</span><br><span class="line">         <span class="keyword">for</span> (j = i; j &gt;= start &amp;&amp; less(val,a[j-h]); j -= h)</span><br><span class="line">            move(a, j, j-h);</span><br><span class="line">         a[j] = val;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Summary-of-elementary-sorting-Algo"><a href="#Summary-of-elementary-sorting-Algo" class="headerlink" title="Summary of elementary sorting Algo"></a>Summary of elementary sorting Algo</h3><table>
<thead>
<tr>
<th></th>
<th>#compares</th>
<th>-</th>
<th>-</th>
<th>#swaps</th>
<th>-</th>
<th>-</th>
<th>#moves</th>
<th>-</th>
<th>-</th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td>min</td>
<td>avg</td>
<td>max</td>
<td>min</td>
<td>avg</td>
<td>max</td>
<td>min</td>
<td>avg</td>
<td>max</td>
</tr>
<tr>
<td>Selection sort</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$n$</td>
<td>$n$</td>
<td>$n$</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>Bubble sort</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>$0$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>.</td>
<td>.</td>
<td>.</td>
</tr>
<tr>
<td>Insertion sort</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>$n$</td>
<td>$n^2$</td>
<td>$n^2$</td>
</tr>
<tr>
<td>Shell sort</td>
<td>$n$</td>
<td>$n^{4/3}$</td>
<td>$n^{4/3}$</td>
<td>.</td>
<td>.</td>
<td>.</td>
<td>$1$</td>
<td>$n^{4/3}$</td>
<td>$n^{4/3}$</td>
</tr>
</tbody>
</table>
<h2 id="Advanced-Sorting-Algo"><a href="#Advanced-Sorting-Algo" class="headerlink" title="Advanced Sorting Algo"></a>Advanced Sorting Algo</h2><p>Advanced sorting algo can achieve better performance than $O(n^k)\ (k&gt;1)$, which is $O(n\log n)$.</p>
<h3 id="Quick-Sort"><a href="#Quick-Sort" class="headerlink" title="Quick Sort"></a>Quick Sort</h3><p>Quick sorting is not a stable or adaptive sorting algo.</p>
<p>Basic ideas:</p>
<ol>
<li>Pick a value <code>x</code> as <strong><em>pivot</em></strong></li>
<li>Use the pivot to <strong><em>partition</em></strong> the array into 2 parts (<code>&lt;x</code> and <code>&gt;x</code>)</li>
<li>Recursively sort each of the partitions</li>
</ol>
<h4 id="Vanilla-Quick-Sort"><a href="#Vanilla-Quick-Sort" class="headerlink" title="Vanilla Quick Sort"></a>Vanilla Quick Sort</h4><p>Vanilla Quick Sort is the most simple quick sort, where we <u>pick the first value of the list as the pivot</u>.</p>
<p><img src="media/15541784881323/15547150539159.png" alt="-w400"></p>
<p>Partition is the most important part of quick sorting:<br><img src="media/15541784881323/15547157701660.png" alt="-w400"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i; <span class="comment">// index of pivot</span></span><br><span class="line">   <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">   i = partition(a, lo, hi);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Item v = a[lo];  <span class="comment">// pivot</span></span><br><span class="line">    <span class="keyword">int</span>  i = lo+<span class="number">1</span>, j = hi;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// let i point to the item greater than mid</span></span><br><span class="line">        <span class="keyword">while</span> (less(a[i], v) &amp;&amp; i &lt; j) i++;</span><br><span class="line">        <span class="comment">// let j point to the item smaller than mid</span></span><br><span class="line">        <span class="keyword">while</span> (less(v, a[j]) &amp;&amp; j &gt; i) j--;</span><br><span class="line">        <span class="comment">// if i and j meet, end</span></span><br><span class="line">        <span class="keyword">if</span> (i == j) <span class="keyword">break</span>;</span><br><span class="line">        swap(a, i, j);</span><br><span class="line">    &#125;</span><br><span class="line">    j = less(a[i],v) ? i : i<span class="number">-1</span>;</span><br><span class="line">    swap(a, lo, j);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Performance:</p>
<ul>
<li>Best case: $O(n\log n)$ comparisons<ul>
<li>choice of pivot gives two equal-sized partitions</li>
<li>same happens at every recursive level</li>
<li>each “level” requires approx n comparisons</li>
<li>halving at each level ⇒ log2n levels</li>
</ul>
</li>
<li>Worst case: $O(n^2)$ comparisons<ul>
<li>==always choose lowest/highest value for pivot==</li>
<li>partitions are size 1 and n-1</li>
<li>each “level” requires approx n comparisons</li>
<li>partitioning to 1 and n-1 ⇒ n levels</li>
</ul>
</li>
</ul>
<h4 id="Improved-Qucik-Sort"><a href="#Improved-Qucik-Sort" class="headerlink" title="Improved Qucik Sort"></a>Improved Qucik Sort</h4><h5 id="Handle-max-min-pivot-Median-of-three"><a href="#Handle-max-min-pivot-Median-of-three" class="headerlink" title="Handle max/min pivot: Median-of-three"></a>Handle max/min pivot: Median-of-three</h5><p><em>Choice of pivot</em> can have significant effect: always choosing largest/smallest ⇒ worst case, which </p>
<p>So we need to try to find “intermediate” value.</p>
<p>One way is to choose pivot by median-of-three:</p>
<p><img src="media/15541784881323/15547158401260.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">medianOfThree</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">   <span class="keyword">if</span> (less(a[mid],a[lo])) swap(a, lo, mid);</span><br><span class="line">   <span class="keyword">if</span> (less(a[hi],a[mid])) swap(a, mid, hi);</span><br><span class="line">   <span class="keyword">if</span> (less(a[mid],a[lo])) swap(a, lo, mid);</span><br><span class="line">   <span class="comment">// now, we have a[lo] &lt; a[mid] &lt; a[hi]</span></span><br><span class="line">   <span class="comment">// swap a[mid] to a[lo+1] to use as pivot</span></span><br><span class="line">   swap(a, mid, lo+<span class="number">1</span>); swap(a, lo, mid);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (hi-lo &lt; Threshhold) &#123; ... <span class="keyword">return</span>; &#125;</span><br><span class="line">   medianOfThree(a, lo, hi);</span><br><span class="line">   i = partition(a, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Handle-small-partitions-differently"><a href="#Handle-small-partitions-differently" class="headerlink" title="Handle small partitions differently"></a>Handle small partitions differently</h5><p>Another source of inefficiency:</p>
<ul>
<li>pushing recursion down to very small partitions</li>
<li>overhead in recursive function calls</li>
<li>little benefit from partitioning when size &lt; 5<br>Solution: handle small partitions differently</li>
<li>switch to <strong><em>insertion sort</em></strong> on small partitions, or</li>
<li>don’t sort yet; use post-quicksort insertion sort</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   <span class="keyword">if</span> (hi-lo &lt; Threshhold) &#123;</span><br><span class="line">      insertionSort(a, lo, hi);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   medianOfThree(a, lo, hi);</span><br><span class="line">   i = partition(a, lo+<span class="number">1</span>, hi<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, lo, i<span class="number">-1</span>);</span><br><span class="line">   quicksort(a, i+<span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="Handle-Duplicate-keys-Three-way-partitioning"><a href="#Handle-Duplicate-keys-Three-way-partitioning" class="headerlink" title="Handle Duplicate keys: Three-way partitioning"></a>Handle Duplicate keys: Three-way partitioning</h5><p>If the array contains many duplicate keys</p>
<ul>
<li>standard partitioning does not exploit this: <img src="media/15541784881323/15559065398781.png" alt="-w500"></li>
<li>can improve performance via <strong><em>three-way partitioning</em></strong>: <a href="media/15541784881323/15559065425556.png">-w500</a></li>
</ul>
<p>Bentley/McIlroy approach to three-way partition:<br><img src="media/15541784881323/15559068169195.png" alt="-w500"></p>
<h4 id="Non-recursive-Quicksort"><a href="#Non-recursive-Quicksort" class="headerlink" title="Non-recursive Quicksort"></a>Non-recursive Quicksort</h4><p>Quick sort can be implemented using an explicit stack:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksortStack</span> <span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;  Stack s = newStack();</span><br><span class="line">   StackPush(s,hi); StackPush(s,lo);</span><br><span class="line">   <span class="keyword">while</span> (!StackEmpty(s)) &#123;</span><br><span class="line">      lo = StackPop(s);</span><br><span class="line">      hi = StackPop(s);</span><br><span class="line">      <span class="keyword">if</span> (hi &gt; lo) &#123; </span><br><span class="line">         i = partition (a,lo,hi);</span><br><span class="line">         StackPush(s,hi); StackPush(s,i+<span class="number">1</span>);</span><br><span class="line">         StackPush(s,i<span class="number">-1</span>); StackPush(s,lo);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Merge-Sort"><a href="#Merge-Sort" class="headerlink" title="Merge Sort"></a>Merge Sort</h3><p>Basic idea: (like reverted Quicksort)</p>
<ol>
<li>split the array into two equal-sized partitions until <u>every partition is sorted</u></li>
<li>(recursively) sort each half</li>
<li><strong><em>merge</em></strong> the two partitions back to original array</li>
</ol>
<p><strong><em>Merging</em></strong> is the critical step.<br>Example of a in-place merging:<br>Suppose we have 2 sorted subarrays: <code>a[lo] - a[mid]</code> and <code>a[mid+1] - a [hi]</code> <img src="media/15541784881323/15548962723804.jpg" alt="-w500"></p>
<ol>
<li><p>copy this array into one auxiliary array <code>aux</code>, and make pointers <code>i</code> and <code>j</code> to the smallest values of 2 subarrays <img src="media/15541784881323/15548966926365.jpg" alt="-w550"></p>
</li>
<li><p>(recursively) copy the smaller of the two pointers, and increment the pointer <img src="media/15541784881323/15548968146927.jpg" alt="-w550"></p>
</li>
<li><p>when one exhausted, copy the rest of the other</p>
</li>
</ol>
<p>==In mergesort, sorting is implemented by merging.== They are equivalent.</p>
<p><img src="media/15541784881323/15547162716588.png" alt=""></p>
<p><strong><em>In-place merging</em></strong>: Actually, we can just use two arrays to implement the merge sort to use less memory.</p>
<p>Best case: $O(N\log N)$ comparisons</p>
<ul>
<li>split array into equal-sized partitions</li>
<li>same happens at every recursive level</li>
<li>each “level” requires ≤ N comparisons</li>
<li>halving at each level ⇒ log2N levels</li>
</ul>
<p>Worst case: $O(N\log N)$ comparisons</p>
<ul>
<li>partitions are exactly interleaved</li>
<li>need to compare all the way to end of partitions</li>
</ul>
<p>Disadvantage over quicksort: need extra storage $O(N)$</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>; <span class="comment">// mid point</span></span><br><span class="line">    <span class="keyword">if</span> (hi &lt;= lo) <span class="keyword">return</span>;</span><br><span class="line">    mergesort(a, lo, mid);</span><br><span class="line">    mergesort(a, mid+<span class="number">1</span>, hi);</span><br><span class="line">    merge(a, lo, mid, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">10</span>] = &#123;<span class="number">32</span>,<span class="number">45</span>,<span class="number">17</span>,<span class="number">22</span>,<span class="number">94</span>,<span class="number">78</span>,<span class="number">64</span>,<span class="number">25</span>,<span class="number">55</span>,<span class="number">42</span>&#125;;</span><br><span class="line">mergesort(nums, <span class="number">0</span>, <span class="number">9</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i, j, k, nitems = hi-lo+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// in-place merge just one additional array</span></span><br><span class="line">    Item *tmp = <span class="built_in">malloc</span>(nitems*<span class="keyword">sizeof</span>(Item));</span><br><span class="line"></span><br><span class="line">    i = lo; j = mid+<span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// scan both segments, copying to tmp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i],a[j]))</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy items from unfinished segment</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) tmp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy tmp back to main array</span></span><br><span class="line">    <span class="keyword">for</span> (i = lo, k = <span class="number">0</span>; i &lt;= hi; i++, k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Non-recursive-Mergesort-Bottom-up-mergesort"><a href="#Non-recursive-Mergesort-Bottom-up-mergesort" class="headerlink" title="Non-recursive Mergesort: Bottom-up mergesort ?"></a>Non-recursive Mergesort: Bottom-up mergesort ?</h4><p>Non-recursive mergesort does not require a stack, because partition boundaries can be computed iteratively.</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> min(A,B) ((A &lt; B) ? A : B)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// lo is the first index, hi is the last index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i, m; <span class="comment">// m = length of runs</span></span><br><span class="line">   <span class="keyword">int</span> end; <span class="comment">// end of 2nd run</span></span><br><span class="line">   <span class="keyword">for</span> (m = <span class="number">1</span>; m &lt;= lo-hi; m = <span class="number">2</span>*m) &#123;</span><br><span class="line">      <span class="keyword">for</span> (i = lo; i &lt;= hi-m; i += <span class="number">2</span>*m) &#123;</span><br><span class="line">         end = min(i+<span class="number">2</span>*m<span class="number">-1</span>, hi);</span><br><span class="line">         merge(a, i, i+m<span class="number">-1</span>, end); <span class="comment">// this still need a tmp array</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> mid, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  i, j, k, nitems = hi-lo+<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// in-place merge just one additional array</span></span><br><span class="line">    Item *tmp = <span class="built_in">malloc</span>(nitems*<span class="keyword">sizeof</span>(Item));</span><br><span class="line"></span><br><span class="line">    i = lo; j = mid+<span class="number">1</span>; k = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// scan both segments, copying to tmp</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= hi) &#123;</span><br><span class="line">        <span class="keyword">if</span> (less(a[i],a[j]))</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// copy items from unfinished segment</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= mid) tmp[k++] = a[i++];</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= hi) tmp[k++] = a[j++];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//copy tmp back to main array</span></span><br><span class="line">    <span class="keyword">for</span> (i = lo, k = <span class="number">0</span>; i &lt;= hi; i++, k++)</span><br><span class="line">        a[i] = tmp[k];</span><br><span class="line">    <span class="built_in">free</span>(tmp);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Mergesort-Variation"><a href="#Mergesort-Variation" class="headerlink" title="Mergesort Variation"></a>Mergesort Variation</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// lo is the first index, hi is the last index</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(Item a[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> i;</span><br><span class="line">   Item *aux = <span class="built_in">malloc</span>((hi+<span class="number">1</span>)*<span class="keyword">sizeof</span>(Item));</span><br><span class="line">   <span class="keyword">for</span> (i = lo; i &lt;= hi; i++) aux[i] = a[i];</span><br><span class="line">   doMergeSort(a, aux, lo, hi);</span><br><span class="line">   <span class="built_in">free</span>(aux);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doMergeSort</span><span class="params">(Item a[], Item b[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if not need sort, return</span></span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// otherwise, merge sort</span></span><br><span class="line">    <span class="comment">// find the mid</span></span><br><span class="line">    <span class="keyword">int</span> mid = (lo+hi)/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">// mergesort two partitions</span></span><br><span class="line">    doMergeSort(b, a, lo, mid);</span><br><span class="line">    doMergeSort(b, a, mid+<span class="number">1</span>, hi);</span><br><span class="line">    <span class="comment">// merge those sorted arrays</span></span><br><span class="line">    merge(b+lo, mid-lo+<span class="number">1</span>, b+mid+<span class="number">1</span>, hi-mid, a+lo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// what actually sorts array</span></span><br><span class="line"><span class="comment">// merge arrays a[] and b[] into c[]</span></span><br><span class="line"><span class="comment">// aN = size of a[], bN = size of b[]</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(Item a[], <span class="keyword">int</span> aN, Item b[], <span class="keyword">int</span> bN, Item c[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i; <span class="comment">// index into a[]</span></span><br><span class="line">    <span class="keyword">int</span> j; <span class="comment">// index into b[]</span></span><br><span class="line">    <span class="keyword">int</span> k; <span class="comment">// index into c[] </span></span><br><span class="line">    <span class="keyword">for</span> (i = j = k = <span class="number">0</span>; k &lt; aN+bN; k++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == aN)</span><br><span class="line">            c[k] = b[j++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j == bN)</span><br><span class="line">            c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (less(a[i],b[j]))</span><br><span class="line">            c[k] = a[i++];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            c[k] = b[j++];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="External-Merge-Sort"><a href="#External-Merge-Sort" class="headerlink" title="External Merge Sort"></a>External Merge Sort</h4><p>Previous sorts all assume …</p>
<ul>
<li>efficient random access to Items</li>
<li>which suggests that data is in arrays in memory</li>
<li>which limits sortable data to what fits in memory</li>
</ul>
<p>When the data is in disk files</p>
<ul>
<li>random access is inefficient (files are sequential access)</li>
<li>but max data size is far less constrained</li>
</ul>
<p>Because mergesort makes multiple sequential passes, it adapts well as a sorting approach for files.</p>
<p>External mergesort basic idea:</p>
<ul>
<li>have two files, A and B, which alternate as input/output</li>
<li>scan input, sorting adjacent pairs, write to output</li>
<li>scan input, merging pairs to sorted runs of length 4</li>
<li>scan input, merging pairs to sorted runs of length 8</li>
<li>repeat until entire file is sorted</li>
</ul>
<p>How many iterations are needed?</p>
<ul>
<li>double scan length until ≥ file size ($N$ Items)</li>
<li>#iterations =  $\log_2N$</li>
</ul>
<p><img src="media/15541784881323/15547882455257.png" alt=""></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="built_in">stdin</span>, containing N Items</span><br><span class="line">Output: stream of Items on <span class="built_in">stdout</span></span><br><span class="line"></span><br><span class="line">copy <span class="built_in">stdin</span> file to A</span><br><span class="line">runLength = <span class="number">1</span></span><br><span class="line">iter = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> (runLength &lt; N) &#123;</span><br><span class="line">    <span class="keyword">if</span> (iter % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        inFile = A, outFile = B</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        inFile = B, outFile = A</span><br><span class="line">    fileMerge(inFile, outFile, runLength, N)</span><br><span class="line">    iter++;</span><br><span class="line">    runLength *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">copy outfile to <span class="built_in">stdout</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// assumes N = 2^k for some integer k &gt; 0</span></span><br><span class="line">fileMerge(inFile, outFile, runLength, N)</span><br><span class="line">&#123;</span><br><span class="line">   inf1 = open inFile <span class="keyword">for</span> reading</span><br><span class="line">   inf2 = open inFile <span class="keyword">for</span> reading</span><br><span class="line">   outf = open outFile <span class="keyword">for</span> writing</span><br><span class="line">   in1 = <span class="number">0</span>; in2 = runLength</span><br><span class="line">   <span class="keyword">while</span> (in1 &lt; N) &#123;</span><br><span class="line">      seek to position in1 in inf1</span><br><span class="line">      end1 = in1+runLength</span><br><span class="line">      it1 = getItem(inf1)</span><br><span class="line">      seek to position in2 in inf2</span><br><span class="line">      end2 = in2+runLength</span><br><span class="line">      it2 = getItem(inf2)</span><br><span class="line">      <span class="keyword">while</span> (in1 &lt; end1 &amp;&amp; in2 &lt; end2) &#123;</span><br><span class="line">         <span class="keyword">if</span> (less(it1,it2)) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">else</span> &#123;</span><br><span class="line">            write it2 to outf</span><br><span class="line">            it2 = getItem(inf2); in2++</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">while</span> (in1 &lt; end1) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">      &#125;</span><br><span class="line">        <span class="keyword">while</span> (in2 &lt; end2) &#123;</span><br><span class="line">            write it1 to outf</span><br><span class="line">            it1 = getItem(inf1); in1++</span><br><span class="line">        &#125;</span><br><span class="line">        in1 += runLength; in2 += runLength;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Heap-Sort"><a href="#Heap-Sort" class="headerlink" title="Heap Sort"></a>Heap Sort</h3><p>We can create a heap, and repeatedly insert and remove from a heap, which is $O(2n\log n)=O(n \log n)$</p>
<h3 id="Comparison-between-Mergesort-and-Quicksort"><a href="#Comparison-between-Mergesort-and-Quicksort" class="headerlink" title="Comparison between Mergesort and Quicksort"></a>Comparison between Mergesort and Quicksort</h3><p>Why quicksort is better than mergesort?<br>There are certain reasons due to which quicksort is better especially in case of arrays:</p>
<ol>
<li><strong>Auxiliary Space</strong>: Mergesort uses extra space, quicksort requires little space and exhibits good cache locality.(in-place sorting)</li>
<li><strong>Worst Cases</strong>: The worst case of quicksort $O(n^2)$ can be avoided by using randomized quicksort. It can be easily avoided with high probability by choosing the right pivot. Obtaining an average case behavior by choosing right pivot element makes it improvise the performance and becoming as efficient as Merge sort.</li>
<li><strong>Locality of reference</strong> : Quicksort in particular exhibits good cache locality and this makes it faster than merge sort in many cases like in virtual memory environment.</li>
<li><strong>Merge sort is better for large data structures</strong>: Mergesort is a stable sort (unlike quicksort and heapsort) and can be easily adapted to operate on linked lists and very large lists stored on slow-to-access media.</li>
</ol>
<h2 id="Summary-of-Comparison-Based-Sorting"><a href="#Summary-of-Comparison-Based-Sorting" class="headerlink" title="Summary of Comparison-Based Sorting"></a>Summary of Comparison-Based Sorting</h2><ul>
<li>Selection sort:<ul>
<li>stability depends on implementation</li>
<li>not adaptive</li>
</ul>
</li>
<li>Bubble sort:<ul>
<li>stable if items don’t move past same-key items</li>
<li>adaptive if it terminates when no swaps</li>
</ul>
</li>
<li>Insertion sort:<ul>
<li>stability depends on implementation of insertion</li>
<li>adaptive if it stops scan when position is found</li>
</ul>
</li>
<li>Quicksort:<ul>
<li>easy to make stable on lists; difficult on arrays</li>
<li>can be adaptive depending on implementation</li>
</ul>
</li>
<li>Merge sort:<ul>
<li>is stable if merge oeration is stable</li>
<li>can be made adaptive (but above version is not)</li>
</ul>
</li>
</ul>
<h3 id="Sorting-Lower-Bound-for-Comparison-Based-Sorting"><a href="#Sorting-Lower-Bound-for-Comparison-Based-Sorting" class="headerlink" title="Sorting Lower Bound for Comparison-Based Sorting"></a>Sorting Lower Bound for Comparison-Based Sorting</h3><p>Many popular sorting algorithms “compare” pairs of keys (objects) to sort an input sequence.</p>
<p>Lower Bound: Any comparison-based sorting algorithm must take Ω (n log n) time to sort n elements in the worst case.</p>
<p>Given $n$ elements (no duplicates),</p>
<ul>
<li>there are $n!$ possible permutation sequences</li>
<li>one of these possible sequences is a sorted sequence</li>
<li>each comparision reduces number of possible sequences to be considered</li>
</ul>
<p><img src="media/15541784881323/15547866806568.png" alt=""></p>
<p>For a given input,</p>
<ul>
<li>the algorithm follows a path from the root to a leaf</li>
<li>requires one comparison at each level</li>
<li>there are $n!$ leaves for $n$ elements</li>
<li>height of such tree is at least $\log_2(n!)$, so number of comparisions required is at least $log_2(n!)$</li>
</ul>
<p>$$\log_2(n!) = \log_2(1) + \log_2(2) + … + \log_2(n/2) + … + \log_2(n-1) + \log_2(n)<br>\ \log_2(n!) &gt;=  \log_2(n/2) + … + \log_2(n-1) + \log_2(n)<br>\ \log_2(n!) &gt;=  (n/2)\log_2(n/2)<br>\ \log_2(n!) =  Ω (n \log_2 n)$$</p>
<p>==Therefore, for any comparison-based sorting algorithm, the lower bound is $Ω (n \log_2 n)$.==</p>
<h2 id="Non-comparison-based-Sorting-Algo"><a href="#Non-comparison-based-Sorting-Algo" class="headerlink" title="Non comparison-based Sorting Algo"></a>Non comparison-based Sorting Algo</h2><h3 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h3><p>Radix sort is a non-comparative sorting algorithm.</p>
<p>Radix sort basic idea:</p>
<ul>
<li>represent key as a tuple $(k_1, k_2, …, k_m)$</li>
<li>finite and normally few possible values of $k_i$</li>
<li><p>sorting algorithm:</p>
<ul>
<li><strong>stable</strong> sort on $k_m$,</li>
<li>then <strong>stable</strong> sort on $k_{(m-1)}$,</li>
<li>similarly continue until $k_1$</li>
</ul>
<p><img src="media/15541784881323/15547874455855.png" alt=""></p>
</li>
</ul>
<p>Time complexity:</p>
<ul>
<li>stable sort like bucket/pigeonhole sort runs in time $O(n)$</li>
<li>radix sort runs in time $O(mn)$ , where $m$ is number of sub-keys ($k_i$ in a tuple above)</li>
<li>radix sort performs better (==for sufficiently large $n$==) than the best comparison-based sorting algorithms</li>
</ul>
<h3 id="Bucket-Pigeonhole-Sort"><a href="#Bucket-Pigeonhole-Sort" class="headerlink" title="Bucket/Pigeonhole Sort"></a>Bucket/Pigeonhole Sort</h3><p>Bucket sort is a common way for the stable sorting in the radix sort.</p>
<p>Bucket/Pigeonhole sort basic idea:</p>
<ul>
<li>finite and normally few possible values of keys, for example<ul>
<li>numeric: 0 to 9</li>
<li>week days: monday, tuesday, wednesday, thursday, friday, saturday, sunday</li>
<li>months: january to december</li>
</ul>
</li>
<li>each key value maps to an index into the array of buckets/pigeonholes</li>
<li>one bucket (pigeonhole) per key value</li>
<li>sorting algorithm:<ul>
<li>phase-1: move each entry from the input sequence to the corresponding bucket (say queue) in the array of buckets</li>
<li>phase-2: move entries of each bucket, in the required order, to the end of the output sequence</li>
</ul>
</li>
</ul>
<p>Time complexity: bucket sort runs in time $O(n)$, assuming number of buckets is not large.</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/25/Hashing Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/25/Hashing Algo/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-25T22:35:05-05:00">
                2019-03-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Hashing-Algo"><a href="#Hashing-Algo" class="headerlink" title="Hashing Algo"></a>Hashing Algo</h1><p>Key-indexed arrays had “perfect” search performance O(1)</p>
<ul>
<li>but required a dense range of index values</li>
<li>used a fixed-size array (max size ever needed)</li>
<li>bigger array ⇒ more useful but wastes more space</li>
</ul>
<p>Hashing allows us to approximate this performance, but</p>
<ul>
<li>allows arbitrary types of keys</li>
<li>map (hash) keys into compact range of index values</li>
<li>store items in array, accessed by index value</li>
</ul>
<p>The ideal for key-indexed collections:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">courses[&quot;COMP3311&quot;] = &quot;Database Systems&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;, courses[&quot;COMP3311&quot;]);</span><br></pre></td></tr></table></figure></p>
<p>Almost as good:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">courses[h(&quot;COMP3311&quot;)] = &quot;Database Systems&quot;;</span><br><span class="line">printf(&quot;%s\n&quot;, courses[h(&quot;COMP3311&quot;)]);</span><br></pre></td></tr></table></figure></p>
<p><img src="media/15535713050580/15535732749671.png" alt=""></p>
<p>To use arbitrary values as keys, we need three things:</p>
<ul>
<li>set of <strong><em>Key</em></strong> values, each key identifies one Item</li>
<li>an array (of size $N$) to store <em>Item</em>s</li>
<li>a <strong><em>hash function</em></strong> $h()$ of type Key→[0..N-1]<ul>
<li>requirement: if $(x == y)$ then $h(x) == h(y)$</li>
<li>requirement: $h(x)$ always returns same value for given $x$</li>
</ul>
</li>
<li>a <strong><em>collision resolution</em></strong> method<ul>
<li>collision = (x != y &amp;&amp; h(x) == h(y))</li>
<li>collisions are inevitable when dom(Key) &gt;&gt; N</li>
</ul>
</li>
</ul>
<p>Notes:</p>
<ul>
<li>converts <em>Key</em> value to index value [0..N-1]</li>
<li>deterministic (key value k always maps to same value)</li>
<li>use <em>mod</em> function to map hash value to index value</li>
<li>spread key values <em>uniformly</em> over address range (assumes that keys themselves are <em>uniformly</em> distributed)</li>
<li>Avoid collisions as much as possible, h(k) ≠ h(j) if j ≠ k</li>
<li>cost of computing hash function must be cheap</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HashTabRep</span> &#123;</span></span><br><span class="line">   <span class="keyword">int</span>  N;       <span class="comment">// size of array</span></span><br><span class="line">   Item **items; <span class="comment">// array of (Item *)</span></span><br><span class="line">&#125; HashTabRep;</span><br><span class="line"></span><br><span class="line"><span class="comment">// create a new hash table</span></span><br><span class="line"><span class="function">HashTable <span class="title">newHashTable</span><span class="params">(<span class="keyword">int</span> N)</span>   <span class="comment">// N is the size of the hash table</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   HashTable <span class="keyword">new</span> = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTabRep));</span><br><span class="line">   <span class="keyword">new</span>-&gt;items = <span class="built_in">malloc</span>(N*<span class="keyword">sizeof</span>(Item *));</span><br><span class="line">   <span class="keyword">new</span>-&gt;N = N;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">      &#123; <span class="keyword">new</span>-&gt;items[i] = <span class="literal">NULL</span>; &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hash function</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Key key, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> val = convert key to <span class="keyword">int</span>;</span><br><span class="line">   <span class="keyword">return</span> val % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Examples-for-Hash-Functions"><a href="#Examples-for-Hash-Functions" class="headerlink" title="Examples for Hash Functions"></a>Examples for Hash Functions</h2><h3 id="Sum"><a href="#Sum" class="headerlink" title="Sum"></a>Sum</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">0</span>; <span class="keyword">char</span> *c;</span><br><span class="line">    <span class="keyword">for</span> (c = key; *c != <span class="string">'\0'</span>; c++)</span><br><span class="line">        h = h + *c;</span><br><span class="line">    <span class="keyword">return</span> h % N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>A slightly more sophisticated hash function:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> h = <span class="number">0</span>;  <span class="keyword">char</span> *c;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">127</span>; <span class="comment">// a prime number</span></span><br><span class="line">   <span class="keyword">for</span> (c = key; *c != <span class="string">'\0'</span>; c++)</span><br><span class="line">      h = (a * h + *c) % N;</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>To use all of value in hash, with suitable “randomization”:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(<span class="keyword">char</span> *key, <span class="keyword">int</span> N)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   <span class="keyword">int</span> h = <span class="number">0</span>, a = <span class="number">31415</span>, b = <span class="number">21783</span>;</span><br><span class="line">   <span class="keyword">char</span> *c;</span><br><span class="line">   <span class="keyword">for</span> (c = key; *c != <span class="string">'\0'</span>; c++) &#123;</span><br><span class="line">      a = a*b % (N<span class="number">-1</span>);</span><br><span class="line">      h = (a * h + *c) % N;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>A real hash function (from PostgreSQL DBMS):<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">hash_any(<span class="keyword">unsigned</span> <span class="keyword">char</span> *k, <span class="keyword">register</span> <span class="keyword">int</span> keylen, <span class="keyword">int</span> N)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">register</span> uint32 a, b, c, len;</span><br><span class="line">    <span class="comment">// set up internal state</span></span><br><span class="line">    len = keylen;</span><br><span class="line">    a = b = <span class="number">0x9e3779b9</span>;</span><br><span class="line">    c = <span class="number">3923095</span>;</span><br><span class="line">    <span class="comment">// handle most of the key, in 12-char chunks</span></span><br><span class="line">    <span class="keyword">while</span> (len &gt;= <span class="number">12</span>) &#123;</span><br><span class="line">        a += (k[<span class="number">0</span>] + (k[<span class="number">1</span>] &lt;&lt; <span class="number">8</span>) + (k[<span class="number">2</span>] &lt;&lt; <span class="number">16</span>) + (k[<span class="number">3</span>] &lt;&lt; <span class="number">24</span>));</span><br><span class="line">        b += (k[<span class="number">4</span>] + (k[<span class="number">5</span>] &lt;&lt; <span class="number">8</span>) + (k[<span class="number">6</span>] &lt;&lt; <span class="number">16</span>) + (k[<span class="number">7</span>] &lt;&lt; <span class="number">24</span>));</span><br><span class="line">        c += (k[<span class="number">8</span>] + (k[<span class="number">9</span>] &lt;&lt; <span class="number">8</span>) + (k[<span class="number">10</span>] &lt;&lt; <span class="number">16</span>) + (k[<span class="number">11</span>] &lt;&lt; <span class="number">24</span>));</span><br><span class="line">        mix(a, b, c);</span><br><span class="line">        k += <span class="number">12</span>; len -= <span class="number">12</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// collect any data from remaining bytes into a,b,c</span></span><br><span class="line">    mix(a, b, c);</span><br><span class="line">    <span class="keyword">return</span> c % N;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> mix(a,b,c) \</span></span><br><span class="line">&#123; \</span><br><span class="line">  a -= b; a -= c; a ^= (c&gt;&gt;<span class="number">13</span>); \</span><br><span class="line">  b -= c; b -= a; b ^= (a&lt;&lt;<span class="number">8</span>);  \</span><br><span class="line">  c -= a; c -= b; c ^= (b&gt;&gt;<span class="number">13</span>); \</span><br><span class="line">  a -= b; a -= c; a ^= (c&gt;&gt;<span class="number">12</span>); \</span><br><span class="line">  b -= c; b -= a; b ^= (a&lt;&lt;<span class="number">16</span>); \</span><br><span class="line">  c -= a; c -= b; c ^= (b&gt;&gt;<span class="number">5</span>);  \</span><br><span class="line">  a -= b; a -= c; a ^= (c&gt;&gt;<span class="number">3</span>);  \</span><br><span class="line">  b -= c; b -= a; b ^= (a&lt;&lt;<span class="number">10</span>); \</span><br><span class="line">  c -= a; c -= b; c ^= (b&gt;&gt;<span class="number">15</span>); \</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="Collision-Resolution"><a href="#Collision-Resolution" class="headerlink" title="Collision Resolution"></a>Collision Resolution</h2><p>Collision resolution approaches:</p>
<ul>
<li><strong><em>Linear probing</em></strong>: fast if $α &lt;&lt; 1$, complex deletion</li>
<li><strong><em>Double hashing</em></strong>: faster than linear probing, esp for $α ≅ 1$</li>
<li><strong><em>Separate chaining</em></strong>: easy to implement, allows $α &gt; 1$</li>
</ul>
<p>Only chaining allows α &gt; 1, but performance degrades once α &gt; 1.</p>
<h3 id="Closed-hashing-open-addressing"><a href="#Closed-hashing-open-addressing" class="headerlink" title="Closed hashing (open addressing)"></a>Closed hashing (open addressing)</h3><p>A closed hashing can only store the the as many entries as its slots.</p>
<h4 id="Linear-Probing"><a href="#Linear-Probing" class="headerlink" title="Linear Probing"></a>Linear Probing</h4><p><img src="media/15535713050580/15535758448174.png" alt="-w600"></p>
<p>Search cost analysis:</p>
<ul>
<li>cost to reach <u>first <em>Item</em></u> is O(1)</li>
<li>subsequent cost depends how much we need to scan</li>
<li>affected by <strong><em>load</em></strong> $α = M/N$ (i.e. how “full” is the table)</li>
<li>Avg. Cost for successful search = $0.5*(1 + 1/(1-α))$</li>
<li>Avg. Cost for unsuccessful search = $0.5*(1 + 1/(1-α)2)$</li>
</ul>
<h4 id="Double-hashing"><a href="#Double-hashing" class="headerlink" title="Double hashing"></a>Double hashing</h4><p>We use a secondary hashing to calculate a new index (==first hashing + secondary hashing==), when a collision happened.</p>
<p><u>Can be significantly better than linear probing</u>, especially if table is heavily loaded.</p>
<h3 id="Open-hashing-separate-chaining"><a href="#Open-hashing-separate-chaining" class="headerlink" title="Open hashing (separate chaining)"></a>Open hashing (separate chaining)</h3><p>Store items in a linked list <u>with an ascending order</u> (==the linked list is ordered!==)</p>
<p><img src="media/15535713050580/15535757961280.png" alt="-w600"></p>
<p>Worst case: all items share one identical key, forming a very long chains.<br>Cost: to insert $k$ items, we cost $(k-1) + (k-2) + … +2+1=O(k^2)$</p>
<p>Best case: all items all distributed equally, all chains have the same length<br>Cost: $O(1)$</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/04/Search Tree Algo/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/03/04/Search Tree Algo/" itemprop="url">未命名</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-03-04T18:02:58-06:00">
                2019-03-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Search-Tree-Algo"><a href="#Search-Tree-Algo" class="headerlink" title="Search Tree Algo"></a>Search Tree Algo</h1><p>Common search structures:</p>
<ol>
<li>Linked list<ul>
<li>access: $O(n)$</li>
<li>insert: $O(1)$</li>
<li>search: $O(n)$ (slow)</li>
</ul>
</li>
<li>Array List<ul>
<li>access: $O(1)$</li>
<li>insert: $O(n)$ (need to copy its original content to a new array, slow)</li>
<li>search: $O(\log n)$</li>
</ul>
</li>
<li><strong>Binary Search Tree</strong><ul>
<li>search/insert/delete: $O(\log n)+ dynamic$, much more effcient</li>
<li>recursive structure: can use compact code to implement</li>
</ul>
</li>
</ol>
<h2 id="Binary-Search"><a href="#Binary-Search" class="headerlink" title="Binary Search"></a>Binary Search</h2><p>Property 12.5 Binary search never uses more than $|lg N| + 1$ comparisons for a search (hit or miss).</p>
<p>If we need to insert new items dynamically, it seems that we need a linked structure, but a singly linked list does not lead to an efficient implementation, because the efficiency of binary search depends on our ability to get to the middle of any subarray quickly via indexing, and the only way to get to the middle of a singly linked list is to follow links. </p>
<p>To combine the efficiency of binary search with the flexibility of linked structures, we need more complicated data structures: <strong>Search Tree</strong>.</p>
<h3 id="Binary-Search-Tree"><a href="#Binary-Search-Tree" class="headerlink" title="Binary Search Tree"></a>Binary Search Tree</h3><h4 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h4><p>In BST, there are 2 kinds of nodes:</p>
<ol>
<li><strong><em>Internal node</em></strong>: nodes that contain 2 links that point to other nodes<ul>
<li>(In BST) each node has exactly two links: <strong><em>left</em></strong> and <strong><em>right link</em></strong>s.</li>
<li>Each internal node has an item with a <strong><em>key value</em></strong>, which will be compared with the search key.</li>
</ul>
</li>
<li><strong><em>External node</em></strong> (leaf): nodes that have no links to children nodes<ul>
<li>Links pointing to external nodes are called as <strong><em>null link</em></strong>s.</li>
</ul>
</li>
</ol>
<blockquote>
<p><strong>Definition 12.2</strong>: A <strong><em>binary search tree (BST)</em></strong> is a binary tree that has a key associated with each of its internal nodes, with the additional property that the key in any node is larger than (or equal to) the keys in all nodes in that node’s left subtree and smaller than (or equal to) the keys in all nodes in that node’s right subtree.</p>
</blockquote>
<p>Other special kinds of tree</p>
<ul>
<li>m-ary tree: each internal node has exactly m children</li>
<li>Ordered tree: all left values &lt; root, all right values &gt; root</li>
<li>Balanced tree: has ≅minimal height for a given number of nodes</li>
<li>Degenerate tree: has ≅maximal height for a given number of nodes</li>
</ul>
<h4 id="Insert-and-Search-in-a-BSTree"><a href="#Insert-and-Search-in-a-BSTree" class="headerlink" title="Insert and Search in a BSTree"></a>Insert and Search in a BSTree</h4><p>The basic function in BST is <strong><em>comparison</em></strong>: both insertions and searches need it.</p>
<p>Characteristics of Insertion in BSTs:</p>
<ul>
<li>New nodes are always attached to null links at the bottom of the tree.</li>
<li>The BST functions do not explicitly check for items with duplicate keys.</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BSTree insertR(BSTree t, int v)</span><br><span class="line">if empty return newNode</span><br><span class="line"></span><br><span class="line">if v &lt; t-&gt;value, insertR(t-&gt;left, v)</span><br><span class="line">else if v &gt; t-&gt;value, insertR(t-&gt;right, v)</span><br><span class="line"></span><br><span class="line">return t</span><br></pre></td></tr></table></figure>
<p>For BSTree, <code>search</code> is similar to <code>insert</code>. But there are 2 kinds of <code>search</code>:</p>
<ol>
<li><strong><em>search hit</em></strong>: find the target key value in the path, which is quicker than insertion</li>
<li><strong><em>search miss</em></strong>: cannot find the target key value, which is similar to insertion (both iterate to external nodes)</li>
</ol>
<h4 id="Performance-Characteristics-of-BSTs"><a href="#Performance-Characteristics-of-BSTs" class="headerlink" title="Performance Characteristics of BSTs"></a>Performance Characteristics of BSTs</h4><h5 id="Best-cases-and-Worst-cases-Balanced-or-unbalanced"><a href="#Best-cases-and-Worst-cases-Balanced-or-unbalanced" class="headerlink" title="Best cases and Worst cases: Balanced or unbalanced"></a>Best cases and Worst cases: Balanced or unbalanced</h5><p>The main source of time cost for BSTs is <em>comparison</em>. So the running times of binary search trees are dependent on <u>the shapes of the trees</u>.</p>
<ul>
<li>In the best case where the tree is <em>perfectly balanced</em>, the time cost is $\lg n$, because there are about $\lg N$ nodes between the root and each external node. ==(same as binary search)==</li>
<li>In the worst case where the tree is <em>extremely unbalanced</em> (just has one continuous path), the time cost is $N$, because there are $N$ nodes between the root and the farest external node.</li>
</ul>
<p>These 2 cases are also called:</p>
<ul>
<li>==<strong><em>Balanced tree</em></strong>==: has ≅ minimal height for a given number of nodes</li>
<li>==<strong><em>Degenerate tree</em></strong>==: has ≅ maximal height for a given number of nodes</li>
</ul>
<p>Mathematical definition for balanced tree: $bf=h(L_{ST})-h(R_{ST})$ (bf = balance factor)</p>
<ul>
<li>$|bf| \leq 1$: balanced</li>
<li>$|bf| &gt; 1$: unbalanced</li>
</ul>
<p>Notes: This worst-case arises when we insert keys in order or in reverse order into an initially empty tree, which we should avoid.</p>
<p><img src="media/15517441780156/15520433579778.jpg" alt="-w200"></p>
<h5 id="Average-Performance"><a href="#Average-Performance" class="headerlink" title="Average Performance"></a>Average Performance</h5><p>On average, we can calculate that Insertions and search misses require about $2\ln N$ for a N-key BST.</p>
<p>This means that the search cost for BSTs would be 39% higher than that for binary search for random keys, ==but the extra cost is well worthwhile==, because a new key can be inserted at about the same cost—flexibility not available with binary search.</p>
<h3 id="BST-improvement"><a href="#BST-improvement" class="headerlink" title="BST improvement"></a>BST improvement</h3><h4 id="Alternative-Insertion-Insertion-at-the-Root"><a href="#Alternative-Insertion-Insertion-at-the-Root" class="headerlink" title="Alternative Insertion: Insertion at the Root"></a>Alternative Insertion: Insertion at the Root</h4><p>Now, we consider an alternative insertion method, where each new item be inserted at the root, so recently inserted nodes are at the top of the tree. </p>
<p>This method plays a crucial role in two of the improved BST algorithms.</p>
<p>Let’s consider this process:</p>
<ol>
<li>Suppose that the key of the item to be inserted is larger than the key at the root. </li>
<li>We can make a new tree whose root is the new root node: <ul>
<li>the old root as the left subtree and </li>
<li>the right subtree of the old root as the right subtree.</li>
</ul>
</li>
<li>However, the right subtree may contain some smaller keys, so we need to do extra work to complete the insertion.</li>
<li>Fortunately, there is a simple recursive solution to this problem, which is based on <strong><em>rotation</em></strong>, a fundamental transformation on trees.</li>
</ol>
<p>Advantages:</p>
<ul>
<li>Recently-inserted items are close to root, therefore low cost if recent items more likely to be searched.<ul>
<li>For some applications, search favours recently-added items.</li>
</ul>
</li>
<li>tendency to be balanced, but no balance guarantee.</li>
</ul>
<p>Potential disadvantages: large-scale rearrangement of tree for each insert.</p>
<p>Performance: same complexity as for <em>insertion-at-leaf</em>: $O(height)$</p>
<h4 id="Rebalancing-Trees-Rotation"><a href="#Rebalancing-Trees-Rotation" class="headerlink" title="Rebalancing Trees: Rotation"></a>Rebalancing Trees: Rotation</h4><h5 id="Process-of-a-Roation"><a href="#Process-of-a-Roation" class="headerlink" title="Process of a Roation"></a>Process of a Roation</h5><p><img src="media/15517441780156/Untitled%20Diagram.png" alt="Rotation1 -w350"></p>
<p>First, let’s think about basic properties for a bst:</p>
<ul>
<li><em>LcL</em>&lt;PL&lt;R, PL&lt;<em>LcR</em>&lt;R</li>
<li>R&lt;<em>RcL</em>&lt;PR, R&lt;PR&lt;<em>RcR</em></li>
<li>==This is basically their horizontal position on this tree:==<br><img src="media/15517441780156/Untitled%20Diagram%20-1-.png" alt="Rotation2 -w400"></li>
</ul>
<p>Then, if we want to change <em>PL</em> to its root, we can notice that:</p>
<ul>
<li>Only $LcL &lt; PL$, so LcL would be its left subtree</li>
<li>Since $LcR &lt; R &lt; PR$ (R is mid, more balance), R would be a better root for its right subtree</li>
</ul>
<p><u>As we can see, after rotation, the horizontal position between different nodes do not change, but its root changes:</u></p>
<p><img src="media/15517441780156/Rotation3.png" alt="Rotation3 -w400"></p>
<p>But actually, this process is reversible:</p>
<p><img src="media/15517441780156/Rotation4.png" alt="Rotation4 -w400"></p>
<p>==If we see from downside to upside, we can find that this tree is more <em>balanced</em>, <u>because the root is much closer to the <em>median</em></u>.==</p>
<p>==So generally, what rotation does is to rearrange a bst to make its <em>median</em> higher in a tree, finally always on the top.==</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">partition(tree,i):</span><br><span class="line">|  Input  tree with n nodes, index i</span><br><span class="line">|  Output tree with ith item moved to the root</span><br><span class="line">|</span><br><span class="line">|  m=#nodes(left(tree))</span><br><span class="line">|  if i &lt; m then</span><br><span class="line">|     left(tree)=partition(left(tree),i)</span><br><span class="line">|     tree=rotateRight(tree)</span><br><span class="line">|  else if i &gt; m then</span><br><span class="line">|     right(tree)=partition(right(tree),i-m-1)</span><br><span class="line">|     tree=rotateLeft(tree)</span><br><span class="line">|  end if</span><br><span class="line">|  return tree</span><br></pre></td></tr></table></figure>
<p>Analysis of rebalancing: $O(N)$ visits every node</p>
<h5 id="Rotation-and-Double-rotation"><a href="#Rotation-and-Double-rotation" class="headerlink" title="Rotation and Double-rotation"></a>Rotation and Double-rotation</h5><p>Let’s recall <strong><em>balance factor</em></strong>: Balance_factor(Node) = Height(Left_subtree) - Height(Right_subtree)</p>
<p>Instead of just analysing parent and child, we use a new method: considering <em>parent-child-granchild</em> (<strong><em>p-c-g</em></strong> three level analysis)</p>
<p><img src="media/15517441780156/Rotation%202%20-1-.png" alt="Rotation -w600"><br><img src="media/15517441780156/Rotation%202%20-2-.png" alt="Rotation 2 -w600"></p>
<p>As we can see from the graphs, Right rotation is suitable for (+2,+1), and Left rotation is suitable for (-2,-1).</p>
<p><img src="media/15517441780156/AVL-simple-left_K.svg.png" alt="AVL-simple-left_K.svg -w300"></p>
<p>Then what if we encounter (+2,-1) or (-2,+1)? Then we can use <strong><em>double-rotation</em></strong>:</p>
<p><img src="media/15517441780156/AVL-double-rl_K.svg.png" alt="AVL-double-rl_K.svg -w300"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">node *<span class="title">rotate_RightLeft</span><span class="params">(node *X, node *Z)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// Z is by 2 higher than its sibling</span></span><br><span class="line">	Y = left_child(Z); <span class="comment">// Inner child of Z</span></span><br><span class="line">	<span class="comment">// Y is by 1 higher than sibling</span></span><br><span class="line">	t3 = right_child(Y);</span><br><span class="line">	left_child(Z) = t3;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t3 != null)		parent(t3) = Z;</span><br><span class="line">	</span><br><span class="line">	right_child(Y) = Z;</span><br><span class="line">	parent(Z) = Y;</span><br><span class="line">	t2 = left_child(Y);</span><br><span class="line">	right_child(X) = t2;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (t2 != null)		parent(t2) = X;</span><br><span class="line">	</span><br><span class="line">	left_child(Y) = X;</span><br><span class="line">	parent(X) = Y;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">if</span> (BalanceFactor(Y) &gt; <span class="number">0</span>) &#123; <span class="comment">// t3 was higher</span></span><br><span class="line">	    BalanceFactor(X) = –<span class="number">1</span>;  <span class="comment">// t1 now higher</span></span><br><span class="line">	    BalanceFactor(Z) = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">	    <span class="keyword">if</span> (BalanceFactor(Y) == <span class="number">0</span>) &#123;</span><br><span class="line">	        BalanceFactor(X) = <span class="number">0</span>;</span><br><span class="line">	        BalanceFactor(Z) = <span class="number">0</span>;</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="comment">// t2 was higher</span></span><br><span class="line">        BalanceFactor(X) = <span class="number">0</span>;</span><br><span class="line">        BalanceFactor(Z) = +<span class="number">1</span>;  <span class="comment">// t4 now higher</span></span><br><span class="line">    	&#125;</span><br><span class="line">	BalanceFactor(Y) = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">return</span> Y; <span class="comment">// return new root of rotated subtree</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Improved-BST-Structures"><a href="#Improved-BST-Structures" class="headerlink" title="Improved BST Structures"></a>Improved BST Structures</h4><ul>
<li><strong><em>Splay tree</em></strong></li>
<li>AVL tree</li>
<li></li>
</ul>
<h5 id="Splay-Tree"><a href="#Splay-Tree" class="headerlink" title="Splay Tree"></a>Splay Tree</h5><p>A <strong><em>splay tree</em></strong> is a self-adjusting bst, which use appropriate double-rotations to improve tree balance. </p>
<ul>
<li>not strictly balanced (unlike AVL tree), just case about parent-child-granchild three levels</li>
<li>very quick to access</li>
<li>reasonable amortized performance, but still has $O(n)$ in worst case</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">insertSplay(tree,item):</span><br><span class="line">|  Input  tree, item</span><br><span class="line">|  Output tree with item splay-inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then return new node containing item</span><br><span class="line">|  else if item=data(tree) then return tree</span><br><span class="line">|  else if item&lt;data(tree) then</span><br><span class="line">|  |  if left(tree) is empty then</span><br><span class="line">|  |     left(tree)=new node containing item</span><br><span class="line">|  |  else if item&lt;data(left(tree)) then</span><br><span class="line">|  |        // Case 1: left-child of left-child</span><br><span class="line">|  |    left(left(tree))=insertSplay(left(left(tree)),item)</span><br><span class="line">|  |     // left(tree)=rotateRight(left(tree))</span><br><span class="line">|  |     tree=rotateRight(tree)</span><br><span class="line">|  |  else  // Case 2: right-child of left-child</span><br><span class="line">|  |     right(left(tree))=insertSplay(right(left(tree)),item)</span><br><span class="line">|  |     left(tree)=rotateLeft(left(tree))</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return rotateRight(tree)  // second rotation</span><br><span class="line">|  else if item&gt;data(tree) then</span><br><span class="line">|  |  if right(tree) is empty then</span><br><span class="line">|  |     right(tree)=new node containing item</span><br><span class="line">|  |  else if item&lt;data(right(tree)) then</span><br><span class="line">|  |        // Case 3: left-child of right-child</span><br><span class="line">|  |     left(right(tree))=insertSplay(left(right(tree)),item)</span><br><span class="line">|  |     right(tree)=rotateRight(right(tree))</span><br><span class="line">|  |  else  // Case 4: right-child of right-child</span><br><span class="line">|  |     right(right(tree))=insertSplay(right(right(tree)),item)</span><br><span class="line">|  |     // right(tree)=rotateLeft(right(tree))</span><br><span class="line">|  |     tree=rotateLeft(tree)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return rotateLeft(tree)   // second rotation</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure>
<h5 id="AVL-Tree"><a href="#AVL-Tree" class="headerlink" title="AVL Tree"></a>AVL Tree</h5><p>An <strong><em>AVL tree</em></strong> (named after inventors <em>A</em>delson-<em>V</em>elsky and <em>L</em>andis) is a self-balancing binary search tree, which is always strictly balanced.</p>
<p>Approach:</p>
<ul>
<li>insertion (at leaves) may cause imbalance</li>
<li>repair balance as soon as we notice imbalance</li>
<li>repairs done locally, not by overall tree restructure</li>
</ul>
<p>==For a AVL tree, imbalance can be repaired by a single rotation (without double-rotations):==</p>
<ul>
<li>if left subtree too high ($bf&gt;+1$), do right rotation</li>
<li>if right subtree too high ($bf&lt;-1$), do left rotation</li>
</ul>
<p>Analysis of AVL trees:</p>
<ul>
<li>Problem: determining height/depth of subtrees may be expensive.</li>
<li>Performance: All operations take $O(\log n)$ time in both the average and worst cases</li>
<li><u>may not be <strong><em>weight-balanced</em></strong>; subtree sizes may differ</u> <img src="media/15517441780156/height-weight.png" alt="height-weight -w400"></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">insertAVL(tree,item):</span><br><span class="line">|  Input  tree, item</span><br><span class="line">|  Output tree with item AVL-inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then</span><br><span class="line">|     return new node containing item</span><br><span class="line">|  else if item=data(tree) then</span><br><span class="line">|     return tree</span><br><span class="line">|  else</span><br><span class="line">|  |  // insert item</span><br><span class="line">|  |  if item&lt;data(tree) then</span><br><span class="line">|  |     left(tree)=insertAVL(left(tree),item)</span><br><span class="line">|  |  else if item&gt;data(tree) then</span><br><span class="line">|  |     right(tree)=insertAVL(right(tree),item)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  // repair imbalance, critical</span><br><span class="line">|  |  if height(left(tree))-height(right(tree)) &gt; 1 then</span><br><span class="line">|  |     if item&gt;data(left(tree)) then</span><br><span class="line">|  |        // left of left</span><br><span class="line">|  |        left(tree)=rotateLeft(left(tree))</span><br><span class="line">|  |     end if</span><br><span class="line">|  |     // right of left</span><br><span class="line">|  |     tree=rotateRight(tree)</span><br><span class="line">|  |  else if height(right(tree))-height(left(tree)) &gt; 1 then</span><br><span class="line">|  |     if item&lt;data(right(tree)) then</span><br><span class="line">|  |        right(tree)=rotateRight(right(tree))</span><br><span class="line">|  |     end if</span><br><span class="line">|  |     tree=rotateLeft(tree)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  return tree</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure>
<h4 id="2-3-4-Trees"><a href="#2-3-4-Trees" class="headerlink" title="2-3-4 Trees"></a>2-3-4 Trees</h4><p>A 2-3-4 tree is a variation on the B-Tree, which is a multiway tree in which all non-leaf nodes have 2, 3, or 4 children. </p>
<p>Property of a 2-3-4 tree:</p>
<ul>
<li>Each <em>node</em> stores at most 3 values(<em>entries</em>)<ul>
<li>Number of children = (<em>entries</em> + 1) or (zero)</li>
<li>Each internal node is a 2-node (1 value), 3-node (2 values), or 4-node (3 values).</li>
</ul>
</li>
<li>2-3-4 trees are always balanced.</li>
<li>==All the leaves are on the same level. / In a balanced 2-3-4 tree, all leaves are at same distance from the root.==</li>
</ul>
<p>Insertion into a 2-3-4 Tree: ==2-3-4 trees grow “<em>upwards</em>“ from the leaves.==</p>
<ol>
<li>find leaf node where Item belongs (via search)</li>
<li>if not full (i.e. order &lt; 4), insert Item in this node, order++</li>
<li>if node is full (i.e. contains 3 items) <ol>
<li>split into two 2-nodes as leaves, promote middle element to parent</li>
<li>insert item into appropriate leaf 2-node</li>
<li>then, if parent become a 4-node, continue split/promote upwards</li>
<li>if promote to root, and root is a 4-node, split root node and add new root</li>
</ol>
</li>
</ol>
<p>Performance analysis: <u>worst case determined by height $h$</u></p>
<ul>
<li>worst case for height: all nodes are 2-nodes, similar to balanced BSTs $h ≅ \log_2 n$</li>
<li>best case for height: all nodes are 4-nodes, balanced tree with branching factor 4, $h ≅ \log_4 n$</li>
</ul>
<p>Insertion algorithm:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">insert(tree,item):</span><br><span class="line">|  Input  2-3-4 tree, item</span><br><span class="line">|  Output tree with item inserted</span><br><span class="line">|</span><br><span class="line">|  if tree is empty then</span><br><span class="line">|     return new node containing item</span><br><span class="line">|  end if</span><br><span class="line">|  node=Search(tree,item)</span><br><span class="line">|  parent=parent of node</span><br><span class="line">|  if node.order&lt;4 then</span><br><span class="line">|     insert item into node</span><br><span class="line">|     increment node.order</span><br><span class="line">|  else</span><br><span class="line">|  |  promote = node.data[1]     // middle value</span><br><span class="line">|  |  nodeL   = new node containing data[0]</span><br><span class="line">|  |  nodeR   = new node containing data[2]</span><br><span class="line">|  |  if item&lt;node.data[1] then</span><br><span class="line">|  |     insert(nodeL,item)</span><br><span class="line">|  |  else</span><br><span class="line">|  |     insert(nodeR,item)</span><br><span class="line">|  |  end if</span><br><span class="line">|  |  insert(parent,promote)</span><br><span class="line">|  |  while parent.order=4 do</span><br><span class="line">|  |     continue promote/split upwards</span><br><span class="line">|  |  end while</span><br><span class="line">|  |  if parent is root ∧ parent.order=4 then</span><br><span class="line">|  |     split root, making new root</span><br><span class="line">|  |  end if</span><br><span class="line">|  end if</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="Han">
            
              <p class="site-author-name" itemprop="name">Han</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hangary" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:HangaryLiu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
            <span id="scrollpercent"><span>0</span>%</span>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
