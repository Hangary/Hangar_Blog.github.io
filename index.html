<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform">
<meta http-equiv="Cache-Control" content="no-siteapp">
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css">







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css">

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT">










<meta name="description" content="Stay Hungry, Stay Foolish">
<meta property="og:type" content="website">
<meta property="og:title" content="Hangary Blog">
<meta property="og:url" content="http://yoursite.com/index.html">
<meta property="og:site_name" content="Hangary Blog">
<meta property="og:description" content="Stay Hungry, Stay Foolish">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hangary Blog">
<meta name="twitter:description" content="Stay Hungry, Stay Foolish">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":true,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/">





  <title>Hangary Blog</title>
  








</head>

<body itemscope="" itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope="" itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hangary Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br>
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br>
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br>
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/10/Python 与 Flask 中的上下文（下）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/10/Python 与 Flask 中的上下文（下）/" itemprop="url">Python 与 Flask 中的上下文（下）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-10T00:00:00-05:00">
                2019-09-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python-与-Flask-中的上下文（下）"><a href="#Python-与-Flask-中的上下文（下）" class="headerlink" title="Python 与 Flask 中的上下文（下）"></a>Python 与 Flask 中的上下文（下）</h1><p>最近在学习 <code>Flask</code>，其中 <strong>上下文 Context</strong> 是 <code>Flask</code> 中非常重要的一个概念，而这个命名也来源于 <code>Python</code> 的 <strong>上下文管理器 Context Manager</strong> 机制。所以这里稍微整理一下相关的一些概念。</p>
<h3 id="上下文管理器与多线程、异步编程"><a href="#上下文管理器与多线程、异步编程" class="headerlink" title="上下文管理器与多线程、异步编程"></a>上下文管理器与多线程、异步编程</h3><p>上下文管理器最常用的用法是与多线程/异步编程相配合，因为在这种情况下，我们常常需要切换运行的上下文。</p>
<p>Flask 中的两类上下文：</p>
<ol>
<li><strong>应用上下文 Application Context</strong>: 调用app = Flask(<strong>name</strong>)创建的这个对象app</li>
<li><strong>请求上下文 Request Context</strong>: 每次http请求发生时，WSGI server(比如gunicorn)调Flask.<strong>call</strong>()之后，在Flask对象内部创建的Request对象；</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/09/05/Python 与 Flask 中的上下文（上）/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/09/05/Python 与 Flask 中的上下文（上）/" itemprop="url">Python 与 Flask 中的上下文（上）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-09-05T00:00:00-05:00">
                2019-09-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="Python-与-Flask-中的上下文（上）"><a href="#Python-与-Flask-中的上下文（上）" class="headerlink" title="Python 与 Flask 中的上下文（上）"></a>Python 与 Flask 中的上下文（上）</h1><p>最近在学习 <code>Flask</code>，其中 <strong>上下文 Context</strong> 是 <code>Flask</code> 中非常重要的一个概念，而这个命名也来源于 <code>Python</code> 的 <strong>上下文管理器 Context Manager</strong> 机制。所以这里稍微整理一下相关的一些概念。</p>
<h2 id="什么是-上下文-Context"><a href="#什么是-上下文-Context" class="headerlink" title="什么是 上下文 Context"></a>什么是 上下文 Context</h2><p>在计算机术语中，<strong>上下文 Context</strong> 是一个很广泛的术语，在不同领域往往有不同的含义。我自己的理解是，在编程中，上下文可以理解为 <strong>环境 environment</strong>。</p>
<p><code>Flask</code> 中的视图函数往往需要一些对象来运行，如 <code>request</code>, <code>session</code>, <code>current_app</code> 等。我们有两个选择：</p>
<ol>
<li><strong>函数参数</strong>：将这些对象作为函数参数，传入视图函数。但这种做法会导致程序缺乏可拓展性，我们很难增加新的参数和逻辑。</li>
<li><strong>函数上下文</strong>：将这些对象作为全局变量，这样调用视图函数时，视图函数就会自动在当前的全局空间搜索。这也是 <code>Flask</code> 的做法。</li>
</ol>
<p>但方法 2 也会带来两个问题：</p>
<ol>
<li>如何管理这些上下文。</li>
<li>如何在不同的线程中隔离不同的上下文，既然上下文是全局变量。</li>
</ol>
<p>而 <strong>上下文管理器 Context Manager</strong> 解决的就是第一个问题，它负责创建、绑定并在使用后释放 这些 <strong>上下文 Context</strong>。</p>
<h2 id="Python-中的上下文管理器"><a href="#Python-中的上下文管理器" class="headerlink" title="Python 中的上下文管理器"></a>Python 中的上下文管理器</h2><p>当我们的代码逻辑中出现如下的模式时，<code>Python</code> 的上下文管理器可以帮助我们解耦：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 原代码</span></span><br><span class="line">context_var = enter_func() <span class="comment"># enter logic</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">  ... <span class="comment"># main logic</span></span><br><span class="line">catch:</span><br><span class="line"> 	... <span class="comment"># exception logic</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">  ... <span class="comment"># exit logic</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 使用上下文管理器改写后</span></span><br><span class="line"><span class="keyword">with</span> context_mangaer() <span class="keyword">as</span> context_var:</span><br><span class="line">  ... <span class="comment"># main logic</span></span><br></pre></td></tr></table></figure>
<p>Python 中上下文管理器的主要作用有两个：</p>
<ol>
<li>操作（创建、释放）<strong>资源</strong>，如文件或数据库资源</li>
<li>捕获并处理<strong>异常</strong></li>
</ol>
<h3 id="关键词-with"><a href="#关键词-with" class="headerlink" title="关键词 with"></a>关键词 <code>with</code></h3><p><code>Python</code> 中的上下文机制是通过关键词 <code>with</code> 实现的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> EXPR:</span><br><span class="line">    BLOCK</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们也可以绑定 contextor 的返回值</span></span><br><span class="line"><span class="keyword">with</span> EXPR <span class="keyword">as</span> VAR:</span><br><span class="line">    BLOCK</span><br><span class="line"></span><br><span class="line"><span class="comment"># 也可以绑定多个</span></span><br><span class="line"><span class="keyword">with</span> EXPR1 <span class="keyword">as</span> VAR1, EXPR2 <span class="keyword">as</span> VAR2, ...:</span><br><span class="line">    BLOCK</span><br></pre></td></tr></table></figure>
<p>执行时的逻辑如下：</p>
<ol>
<li>赋值 <code>EXPR</code>， 会返回一个 <strong>上下文管理器 Context Manager</strong>  <code>contextor</code></li>
<li>调用这个 <code>contextor</code> 的 <code>__enter__</code> 方法，并将返回值赋值给 <code>VAR</code> （如果有 <code>as VAR</code>）</li>
<li>执行 <code>BLOCK</code></li>
<li>调用 <code>contextor</code> 的 <code>__exit__</code> 方法</li>
</ol>
<h3 id="上下文管理器类-Context-Manager-Class"><a href="#上下文管理器类-Context-Manager-Class" class="headerlink" title="上下文管理器类 (Context Manager Class)"></a>上下文管理器类 (Context Manager Class)</h3><p>在 <code>Python</code> 中要定义一个上下文管理器其实很简单，只要一个类实现了如下两个方法即可：</p>
<ol>
<li><code>__enter__(self) -&gt; object</code>: <ul>
<li>返回值会被绑定在 <code>VAR</code> 上，一般是这个上下文管理器本身，或者是一个资源对象（如 <code>handle</code>）</li>
</ul>
</li>
<li><code>__exit__(self, exception_type, exception_valve, traceback) -&gt; bool</code>: <ul>
<li>当发生异常时，三个参数会被传入异常的相关信息，否则为 <code>None</code>。</li>
<li>返回值为 <code>True</code>，表明异常被处理。</li>
<li>如果返回值不为 <code>True</code> （即便返回了 <code>None</code>），那么这个异常将会被 <code>with</code> 语句抛出，由更上一层处理。</li>
</ul>
</li>
</ol>
<h3 id="contextmanager-装饰器"><a href="#contextmanager-装饰器" class="headerlink" title="@contextmanager 装饰器"></a><code>@contextmanager</code> 装饰器</h3><p>上面提到的上下文管理器方法，往往是用于给一个资源类增加管理上下文的功能。如果我们只需要 <code>__enter__</code> 和 <code>__exit__</code> 这两个方法，写一个类太过繁杂了。我们可以通过 <code>Python</code> 提供的 <code>@contextmanager</code>  装饰器，来将一个 <strong>生成器 generator</strong> 转化为上下文管理器。</p>
<p>下面就是一个案例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不处理 Excpetion</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_func_without_excp</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># __enter__</span></span><br><span class="line">    file_handler = open(file_name, <span class="string">'r'</span>)</span><br><span class="line">		<span class="comment"># yield 资源对象</span></span><br><span class="line">    <span class="keyword">yield</span> file_handler</span><br><span class="line">    <span class="comment"># __exit__</span></span><br><span class="line">    file_handler.close()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理 Excpetion</span></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_func</span><span class="params">(file_name)</span>:</span></span><br><span class="line">    <span class="comment"># __enter__</span></span><br><span class="line">    file_handler = open(file_name, <span class="string">'r'</span>)</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">try</span>: 	</span><br><span class="line">        <span class="keyword">yield</span> file_handler	<span class="comment"># yield 资源对象</span></span><br><span class="line">    <span class="comment"># exception handler</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> exc:</span><br><span class="line">        print(<span class="string">'the exception was thrown'</span>)</span><br><span class="line">    <span class="comment"># __exit__</span></span><br><span class="line">    file_handler.close()</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open_func(<span class="string">'test.txt'</span>) <span class="keyword">as</span> file_in:</span><br><span class="line">    <span class="keyword">for</span> line <span class="keyword">in</span> file_in:</span><br><span class="line">        <span class="number">1</span>/<span class="number">0</span></span><br><span class="line">        print(line)</span><br></pre></td></tr></table></figure>
<p>同时，<code>contextlib</code> 库中的 <code>closing</code> 函数也可以将一个实现了 <code>close</code> 方法的资源对象转化为一个上下文管理器，这里不再赘述。</p>
<hr>
<p>0参考资料：</p>
<ol>
<li><a href="https://zhuanlan.zhihu.com/p/59070490" target="_blank" rel="noopener">深入理解 Python 中的上下文管理器</a></li>
<li><a href="https://blog.csdn.net/qq_41359051/article/details/83514844" target="_blank" rel="noopener">Python上下文管理器实现的三种方法</a></li>
<li><a href="https://www.jianshu.com/p/d53449f9e7e0" target="_blank" rel="noopener">python黑魔法—上下文管理器（contextor）</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/26/从 Functor 到 Applicative 再到 Monad/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/06/26/从 Functor 到 Applicative 再到 Monad/" itemprop="url">从 Functor 到 Applicative 再到 Monad</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-06-26T00:00:00-05:00">
                2019-06-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="从-Functor-到-Applicative-再到-Monad"><a href="#从-Functor-到-Applicative-再到-Monad" class="headerlink" title="从 Functor 到 Applicative 再到 Monad"></a>从 Functor 到 Applicative 再到 Monad</h1><blockquote>
<p>本文是我在学习 Haskell 期间的一点感悟，不一定正确，但希望可以帮助到一些也在学习 Haskell 的小伙伴们。</p>
</blockquote>
<p>大多数 Monad 尝试解决的是 <strong>副作用 (side effect)</strong> 的问题。</p>
<p>在命令式编程中，大多数函数表现的并不像是数学中的函数，因为它们除了接收输入、返回输出之外，还有可能读写全局变量、进行 IO （如 <code>print</code>）或者修改指针中的值。<br>但是，在纯函数式编程中，一个函数只能接收输入、返回输出。</p>
<p>举个最简单的例子，在 python 中，我们可以使用 <code>print</code> 进行 debugging:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x: float)</span> -&gt; float:</span></span><br><span class="line">    print(<span class="string">"f was called."</span>)</span><br><span class="line">    <span class="keyword">return</span> x * <span class="number">2</span></span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(x: float)</span> -&gt; float:</span></span><br><span class="line">    print(<span class="string">"g was called."</span>)</span><br><span class="line">    <span class="keyword">return</span> x - <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>这就是一个具有副作用的函数，它们不仅返回了计算后的值，还进行了 <code>print</code>。</p>
<p>那么，问题来了：我们在 Haskell 中如何实现这一过程？</p>
<p>一个最基本的思路是，既然函数式编程不允许副作用，那么我们可以尝试修改输出。我们可以创建两个新的函数 <code>f&#39;</code> 与 <code>g&#39;</code>，并且类型为 <code>f&#39;,g&#39; :: Float -&gt; (Float,String)</code>，其中输出元组的 <code>String</code> 就是我们想要的 debug 信息。</p>
<p>图像表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| f&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">f x  &quot;f was called.&quot;</span><br><span class="line"></span><br><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| g&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">g x  &quot;g was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样子，在运行完 <code>f&#39;</code> 与 <code>g&#39;</code> 后，我们就可以通过打印 String 来知道 debug 信息。</p>
<p>但新的问题随之出现，如果我们想要使用一个 <code>f</code> 和 <code>g</code> 的 <strong>函数组合 (Composition)</strong> ，我们该怎么办？<br>在 python 的实现中，<code>f</code> 的输出值和 <code>g</code> 的输入值都是 <code>float</code>，所以它们可以直接连接。但是在 Haskell 中，<code>f</code> 的输出是 <code>(Float,String)</code>，<code>g</code> 的输入是 <code>Float</code>，这似乎没法直接连接。</p>
<p>最简单粗暴的方式是使用 pattern matching，从输出中提取出我们想要的部分：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f'</span> . g' x = <span class="keyword">let</span> (y,s) = g' x</span><br><span class="line">                (z,t) = f' y </span><br><span class="line">            <span class="keyword">in</span> (z,s++t)</span><br></pre></td></tr></table></figure></p>
<p>图像解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     x</span><br><span class="line">     |</span><br><span class="line">   +---+</span><br><span class="line">   | g&apos;|</span><br><span class="line">   +---+</span><br><span class="line">    |   \   </span><br><span class="line">  +---+  | &quot;g was called.&quot;</span><br><span class="line">  | f&apos;|  |</span><br><span class="line">  +---+  |</span><br><span class="line">   | \   |</span><br><span class="line">   |  \  |</span><br><span class="line">   |  +----+</span><br><span class="line">   |  | ++ |</span><br><span class="line">   |  +----+</span><br><span class="line">   |     |</span><br><span class="line">f (g x) &quot;g was called.f was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>但是，我们希望抽象出一种方法，从而避免这样繁琐的工作。即，定义一个 <strong>高阶函数</strong> (<strong>higher-order function</strong>，指接收或返回值为函数的函数) ，可以自动将一个普通的函数“升级”为一个更”宽“的函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">f'</span> :: <span class="type">Float</span> -&gt; (<span class="type">Float</span>,<span class="type">String</span>)</span><br><span class="line"><span class="title">bind</span> :: (<span class="type">Float</span> -&gt; (<span class="type">Float</span>,<span class="type">String</span>)) -&gt; ((<span class="type">Float</span>,<span class="type">String</span>) -&gt; (<span class="type">Float</span>,<span class="type">String</span>))</span><br><span class="line"><span class="title">bind</span> f' :: (<span class="type">Float</span>,<span class="type">String</span>) -&gt; (<span class="type">Float</span>,<span class="type">String</span>)  <span class="comment">-- bind is a higher-order function</span></span><br><span class="line"><span class="title">bind</span> f' (gx,gs) = <span class="keyword">let</span> (fx,fs) = f' gx </span><br><span class="line">                 <span class="keyword">in</span> (fx,gs++fs)</span><br></pre></td></tr></table></figure></p>
<p><code>bind</code> 必须实现两个目的：</p>
<ol>
<li>适配 <code>f&#39;</code> 到 <code>g&#39; x</code> 的结果</li>
<li>将 <code>g&#39;</code> 与 <code>f&#39;</code> 返回的结果关联在一起</li>
</ol>
<p>通过 <code>bind</code> ，我们成功让一个普通的函数 <code>f&#39;</code> 升级成为了一个可以接收更复杂输入的函数。在这里，<code>bind</code> 如同一个胶水，成功的连接了不同的输入在一块。</p>
<h2 id="Functor"><a href="#Functor" class="headerlink" title="Functor"></a>Functor</h2><p><code>Functor</code> 是指一类特殊的类型构造器 (<em>type constructor</em>) 。它可以将某一特定类型的一些值”打包” (<em>wrap</em>) 起来，形成一个上下文 (<em>context</em>)。</p>
<p>一个 <code>Functor</code> 必须具有 kind : <code>* -&gt; *</code>，即接收一个 <strong>实类型 (Concrete type)</strong> ，然后返回一个可以装载这个 concrete type 的 wrapper type。<br>注意，我们现在所讨论的，全都是在类型系统 (type system) 上的概念，和实际的实现无关，即需要分清 wrapper 和 wrapper type 之前的区别。例如，这个 wrapper 的实现可以是 list (linear structure)，tree (branch structure) 甚至是 graph。</p>
<p>让我们来看一下具体实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- kind of f: * -&gt; *</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">Functor</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    fmap :: (a -&gt; b) -&gt; f a -&gt; f b </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Functor</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    <span class="comment">-- fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</span></span><br><span class="line">    <span class="comment">-- f :: a -&gt; b</span></span><br><span class="line">    fmap f (<span class="type">Just</span> x) = <span class="type">Just</span> (f x)  </span><br><span class="line">    fmap f <span class="type">Nothing</span> = <span class="type">Nothing</span></span><br></pre></td></tr></table></figure></p>
<p>对于一个 <code>Functor</code> 的 instance，最重要的函数就是 <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code> （这里的 f 就是一个 wrapper type constructor）。<code>fmap</code> 的本质是一个用于”升级”基本函数的高等函数 (higher-order function)。比方说，我们有一个可以用于原始类型 (primitive data type) 的函数 <code>f</code>，那么我们通过 <code>fmap</code> 就可以将 <code>f</code> 升级成对所有 <code>Functor</code> 都适用的函数，这本质是一种多态和抽象的实现。</p>
<p>如果使用盒子比喻，那么我们首先有一些各种颜色的礼物包装纸 （wrapper type constructor），这些包装纸可以帮助我们判断各个礼物的用途，比如粉红色的包装纸是用于情人节礼物，白色的包装是用于朋友间的礼物，这就是所谓的上下文 context。它们像是一个标签，帮助我们理解礼物的作用，而且，在发货时，这些颜色可以确保我们不会发错礼物，保证了类型安全 (type safety)。</p>
<p>但是，这些包装纸并不可以直接用于包装礼物，我们需要让包装纸对礼物的类型进行剪裁和适配，才能用于包装礼物。这里的礼物类型就是 concrete type，通过给包装纸 (wrapper type constructor) 传入一个礼物类型 (concrete type)，我们就得到了一个可以使用的包装纸类型 (wrapper type)。</p>
<p>那么现在有一个问题，假设我们现在开业大酬宾，希望给每一个礼物都加上一个贺卡，那么我们该怎么做？对于尚未包装的礼物，这很简单，直接使用一个加入贺卡函数即可。但是对于已经包装好的礼物，由于所有不同的包装礼物都具有不同的类型，对每一种包装礼物都写一个对应的加入贺卡函数非常麻烦。这个时候，我们可以抽象出一个过程：<code>打开包装 -&gt; 应用函数 fun -&gt; 重新包装</code>，并写出一个高阶函数 <code>fmap</code>，用于接收 <code>应用函数 fun</code> ，然后返回 <code>打开包装 -&gt; 应用函数 fun -&gt; 重新包装</code>。</p>
<p>但实际上，为了实现这个高阶函数 <code>fmap</code>，我们依旧需要对每一个包装礼物类型 (Functor instance type) 写出对应的 <code>fmap</code> 定义。这么一看，似乎并不比”对每一种包装礼物都写一个对应的加入贺卡函数”更加简单？不对，再来考虑一个新的情况，假设我们现在发现贺卡有问题，希望拿出每一个礼物的贺卡，那么如果我们已经写好了 <code>fmap</code>，这个时候可以直接 <code>fmap 拿出贺卡</code>，从而节省了重复的代码，这就是 <code>fmap</code> 抽象的意义。</p>
<h2 id="Applicative"><a href="#Applicative" class="headerlink" title="Applicative"></a>Applicative</h2><p>Applicative 是对 Functor 的进一步抽象。我们知道，函数式编程的一个特点是函数为第一等公民 (First class function)，函数和值享有同等的地位。那么，既然我们可以“打包”值，那么我们可不可以”打包“一个函数？如果可以，我们该怎么应用这些被”打包”起来的函数？这就是 Applicative 所解决的问题。</p>
<p>我们将能够”打包”一个函数，并将这个”打包”后的函数应用于其他“包裹”的“函数包裹”称呼为 <strong><em>Applicative Functor</em></strong>。</p>
<p>让我们来看一下具体实现：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- f must be an instance of Functor</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> (<span class="type">Functor</span> <span class="title">f</span>) =&gt; <span class="type">Applicative</span> f <span class="keyword">where</span></span>  </span><br><span class="line">    pure :: a -&gt; f a  </span><br><span class="line">    (&lt;*&gt;) :: f (a -&gt; b) -&gt; f a -&gt; f b  </span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Applicative</span> <span class="type">Maybe</span> <span class="keyword">where</span></span>  </span><br><span class="line">    pure = <span class="type">Just</span>  </span><br><span class="line">    <span class="type">Nothing</span> &lt;*&gt; _ = <span class="type">Nothing</span>  </span><br><span class="line">    (<span class="type">Just</span> f) &lt;*&gt; something = fmap f something</span><br></pre></td></tr></table></figure></p>
<p><code>Applicative</code> 中有两个非常重要的函数：</p>
<ul>
<li><code>pure</code>: 用于”打包”一个普通函数。基于<u>构造函数</u> (constructor)实现，但是区别在于 <code>pure</code> 可能会对函数进行一些更进一步的操作。但实际上，如果我们对一个值应用 <code>pure</code>，结果与使用构造函数的结果应该类似。</li>
<li><code>&lt;*&gt;</code>: 基于 <code>fmap</code> 实现，将一个被打包的函数解包，然后使用 <code>fmap</code> 应用在第二个打包的值上。</li>
</ul>
<p>这两个函数看起来似乎并没有什么实际用处，这两个函数能做的，使用上一部分实现的 <code>fmap</code> 也可以做：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">pure</span> (+<span class="number">3</span>) &lt;*&gt; <span class="type">Just</span> <span class="number">9</span>    <span class="comment">-- Just 12</span></span><br><span class="line"><span class="title">fmap</span> (+<span class="number">3</span>) $ <span class="type">Just</span> <span class="number">9</span>      <span class="comment">-- Just 12</span></span><br></pre></td></tr></table></figure></p>
<p>但假设，我们现在有一个函数 <code>fun :: a -&gt; b -&gt; c</code> 需要接收两个输入值，而我们想要输入两个被包裹的值到 <code>fun</code>。这个函数通过 <code>fmap</code> 很难写出：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">fmap</span> (+) $ <span class="type">Just</span> <span class="number">9</span>   <span class="comment">-- Just (9+)</span></span><br><span class="line"><span class="title">fmap</span> (<span class="type">Just</span> (<span class="number">9</span>+)) (<span class="type">Just</span> <span class="number">3</span>)   <span class="comment">-- do not work!</span></span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们就可以使用 <code>&lt;*&gt;</code>:<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(fmap (+) <span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- or more elegant:</span></span><br><span class="line"><span class="title">pure</span> (+) (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>==可以看到，通过 <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>，我们可以优雅地应用一个普通函数 <code>fun</code> 到多个打包值 (wrapper value) 上，而不需要使用 pattern matching！由于 Haskell 的 curried function 特性，我们可以应用具有任意数量参数的函数 <code>fun :: a -&gt; b ... -&gt; output</code>到打包值上。而我们原本 <code>fmap</code> 只能应用接收单个参数的函数 <code>fun :: a -&gt; b</code>到一个打包值，我们的抽象在这里更进一步。==</p>
<p>而且，Haskell 还将具有一个与 <code>fmap</code> 同义的中缀操作符：<code>&lt;$&gt;</code>，于是，我们可以更优雅的改写上面的式子：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(fmap (+) <span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="title">pure</span> (+) (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br><span class="line"><span class="comment">-- equal to</span></span><br><span class="line">(+) &lt;$&gt; (<span class="type">Just</span> <span class="number">9</span>) &lt;*&gt; (<span class="type">Just</span> <span class="number">3</span>)</span><br></pre></td></tr></table></figure></p>
<p>为什么我们要把一个普通函数用 <code>Applicative</code> 打包？</p>
<ol>
<li>方便多个 <code>Functotr</code> 作为输入的函数</li>
<li>在函数上应用 context，确保 type safety</li>
<li>确保值的 context 在应用函数前后一致</li>
</ol>
<p>对第2点举个简单的例子，我们有 <code>double :: Int -&gt; Int</code>，我们可以打包其，变成 <code>Calc double</code>，那么，这个函数就只可以应用在 <code>Calc Int</code> 上，从而确保类型安全。</p>
<h2 id="Monad"><a href="#Monad" class="headerlink" title="Monad"></a>Monad</h2><p>通过 Functor 与 Applicative 这两个抽象，我们已经解决了大部分与”包裹“或者说 context 的问题了：</p>
<ol>
<li>通过 record syntax，我们可以很轻松的将值从 context 中取出</li>
<li>通过 Functor，我们可以在各类不同的 context 下使用同一个基本函数来操作被“包裹”的值 （多态）</li>
<li>通过 Applicative，我们可以在多个被”包裹“的值之间使用基本函数，如加减乘除等等<br>（在这里，基本函数 basic function 指不输入或输出被打包值的函数）</li>
</ol>
<p>但是，这个时候我们可以考虑一类特殊的函数：输入一个普通的值，随后输出一个被”打包“的值的函数。</p>
<p>举个这类函数最简单的例子，为了 debug 我们希望函数 <code>f</code>/<code>g</code> 在输入一个值 <code>x</code> 的时候，不仅输出处理后的结果 <code>y</code>，还会输出 debug 信息，即 <code>f :: Int -&gt; (Int, String)</code>。</p>
<p>图像表述：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| f&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">f x  &quot;f was called.&quot;</span><br><span class="line"></span><br><span class="line">  x</span><br><span class="line">  |</span><br><span class="line">+---+</span><br><span class="line">| g&apos;|</span><br><span class="line">+---+</span><br><span class="line"> |  \ </span><br><span class="line"> |   |</span><br><span class="line">g x  &quot;g was called.&quot;</span><br></pre></td></tr></table></figure></p>
<p>这样子，在运行完 f’ 与 g’ 后，我们就可以通过打印 String 来知道 debug 信息。</p>
<p>但这个时候问题出现了，如果我们想要使用一个 f 和 g 的函数组合 (Composition)，我们该怎么办？即，如何应用一个包含上下文的值 <code>m a</code>，到一个接受普通输入，并附增上上下文的函数 <code>fun :: b -&gt; m b</code>。我们之前的 Functor 和 Applicative 都不能处理这类问题。</p>
<p>我们可以从这个函数开始：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(&gt;&gt;=) :: (<span class="type">Monad</span> m) =&gt; m a -&gt; (a -&gt; m b) -&gt; m b</span><br></pre></td></tr></table></figure></p>
<p>这里，<code>&gt;&gt;=</code> 也被称为 <code>bind</code>。</p>
<p><code>bind</code> 必须实现两个目的：</p>
<ol>
<li>适配 <code>f&#39;</code> 到 <code>g&#39; x</code> 的结果</li>
<li>将 <code>g&#39;</code> 与 <code>f&#39;</code> 返回的结果关联在一起</li>
</ol>
<p>通过 <code>bind</code> ，我们成功让一个普通的函数 <code>f&#39;</code> 升级成为了一个可以接收更复杂输入的函数。在这里，<code>bind</code> 如同一个胶水，成功的连接了不同的输入在一块。</p>
<p>图像解释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">     x</span><br><span class="line">     |</span><br><span class="line">   +---+</span><br><span class="line">   | g&apos;|</span><br><span class="line">   +---+</span><br><span class="line">    |   \   </span><br><span class="line">  +---+  | &quot;g was called.&quot;</span><br><span class="line">  | f&apos;|  |</span><br><span class="line">  +---+  |</span><br><span class="line">   | \   |</span><br><span class="line">   |  \  |</span><br><span class="line">   |  +----+</span><br><span class="line">   |  | ++ |</span><br><span class="line">   |  +----+</span><br><span class="line">   |     |</span><br><span class="line">f (g x) &quot;g was called.f was called.&quot;</span><br></pre></td></tr></table></figure></p>
<h4 id="安全除法"><a href="#安全除法" class="headerlink" title="安全除法"></a>安全除法</h4><p>再举一个例子：”安全除法“。假设我们现在有一个除法函数 <code>myDiv :: Int -&gt; Int -&gt; Int</code>，接收两个数字，相除后输出。这一切暂时看都起来很美好，但是，问题来了：如果我们第二个数字是 <code>0</code> 呢？一旦出现这种情况，那么程序就会崩溃：<code>Exception: divide by zero</code>。</p>
<p>那么，一个可行解决办法是这样：<code>mySafeDiv :: Int -&gt; Int -&gt; Maybe Int</code>。一旦我们的程序遇到除数为 <code>0</code>，我们就输出 <code>Nothing</code>，以此来确保我们的程序可以正常运行且不会奔溃：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mySafeDiv :: Int -&gt; Int -&gt; Maybe Int</span><br><span class="line">mySafeDiv a b = case b of </span><br><span class="line">                    0 -&gt; Nothing</span><br><span class="line">                    _ -&gt; Just (div a b)</span><br></pre></td></tr></table></figure></p>
<p>（在这里，其实我们引入了一个副作用 side effect，用来表示 failure。这与命令式编程中的 <code>try ... exception</code> 非常相似。）</p>
<p>但是，新的问题出现：如果我们想要连续多次地使用 <code>mySafeDiv</code>，例如：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">mySafeDiv</span> (mySafeDiv <span class="number">1</span> <span class="number">3</span>) (mySafeDiv <span class="number">2</span> <span class="number">0</span>)</span><br></pre></td></tr></table></figure></p>
<p>这个时候，我们所写的这段代码会出现问题，因为 <code>mySafeDiv</code> 的输出类型是 <code>Maybe Int</code>，而我们真正所需要的输入数据是 <code>Int</code>，这里就存在着两个问题：</p>
<ol>
<li>真正的数据被”打包“在了 <code>Maybe</code> 这个 context 里，我们需要“解包” <code>Maybe Int</code>。</li>
<li><code>Maybe Int</code> 可能包含着错误情况 <code>Nothing</code>，这个时候，我们希望不使用 <code>mySafeDiv</code>，而直接返回 <code>Nothing</code></li>
</ol>
<p>首先考虑最直接的写法，创建一个新的 <code>myMaybeSafeDiv</code> 函数：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">myMaybeSafeDiv</span> :: <span class="type">Maybe</span> <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span> -&gt; <span class="type">Maybe</span> <span class="type">Int</span></span><br><span class="line"><span class="title">myMaybeSafeDiv</span> a b =</span><br><span class="line">    <span class="keyword">case</span> a <span class="keyword">of</span></span><br><span class="line">        <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">        <span class="type">Just</span> v1 -&gt; <span class="keyword">case</span> b <span class="keyword">of</span></span><br><span class="line">                    <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span></span><br><span class="line">                    <span class="type">Just</span> v2 -&gt; v1 / v2  <span class="comment">-- the real work</span></span><br></pre></td></tr></table></figure></p>
<p>但是，正如我们看到的，这个方法存在两个问题：</p>
<ol>
<li><strong>可读性差</strong>：代码中出现了重复且嵌套的 <code>case ...</code>，并且嵌套会随着参数的增加而增加。这个函数中，真正重要的部分只有最后的 <code>Just v2 -&gt; v1 / v2</code>。</li>
<li><strong>不具有通用性</strong>：如果下一次我们需要写一个类似的函数，如 <code>mySafeLog</code>，那么我们需要这样重复地写一次几乎完全一样的代码。</li>
</ol>
<p>因此，我们需要一个高阶函数，可以将 <code>Maybe Int</code> 强行塞入 <code>mySafeDiv</code> 或 <code>mySafeLog</code> 之类的其他函数，让 <code>Maybe Int</code> 自己自动”解包“或者返回错误。<br>而 <code>bind</code> 函数，就可以帮我们解决这个问题：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">instance</span> <span class="type">Monad</span> <span class="type">Maybe</span> <span class="keyword">where</span></span> </span><br><span class="line">    return = <span class="type">Just</span></span><br><span class="line">    <span class="comment">-- definition of bind</span></span><br><span class="line">    <span class="comment">-- f :: a -&gt; Maybe a</span></span><br><span class="line">    m &gt;&gt;= f   = <span class="keyword">case</span> m <span class="keyword">of</span> </span><br><span class="line">                <span class="type">Nothing</span> -&gt; <span class="type">Nothing</span> </span><br><span class="line">                <span class="type">Just</span> x  -&gt; f x</span><br></pre></td></tr></table></figure></p>
<p>当有了 <code>&gt;&gt;=</code> 之后，我们就可以改写之前的嵌套程序，使其正常运行：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- correct version for </span></span><br><span class="line"><span class="comment">-- mySafeDiv (mySafeDiv 1 3) (mySafeDiv 2 0)</span></span><br><span class="line">(mySafeDiv <span class="number">1</span> <span class="number">3</span>) &gt;&gt;= (\x -&gt; </span><br><span class="line">(mySafeDiv <span class="number">2</span> <span class="number">0</span>) &gt;&gt;= (\y -&gt; </span><br><span class="line">(mySafeDiv x y)))</span><br></pre></td></tr></table></figure></p>
<p>这段代码看上去十分绕脑筋，让我们来分析一下这里发生了什么：</p>
<ol>
<li>首先，我们使用 <code>(mySafeDiv 1 3)</code>，产生了一个 <code>Maybe Int</code> 类型的数据</li>
<li>随后，我们使用 <code>&gt;&gt;=</code> 提取出 <code>(mySafeDiv 1 3)</code> 中包含的 <code>0</code>，输入到 <code>(\x -&gt; (mySafeDiv 2 0) &gt;&gt;= (\y -&gt; (mySafeDiv x y))</code> 中，得到 <code>(mySafeDiv 2 0) &gt;&gt;= (\y -&gt; (mySafeDiv 0 y))</code></li>
<li>随后，计算得出 <code>(mySafeDiv 2 0)</code> 为 <code>Nothing</code>，<code>&gt;&gt;=</code> 通过定义，直接输出了 <code>Nothing</code></li>
</ol>
<p>如何形象地理解这一过程，我们可以使用一个简单的比喻：</p>
<ol>
<li>假设我们有着一系列可以对手机（数据）进行各类质量检测的机器（函数），我们的机器检测完输入的手机后，输出时会给手机加上一些标签（上下文 context），用来记录手机是否是完好的</li>
<li>问题在于，我们机器的传感器只能检测单纯的手机，而不能检测贴上有标签的手机。于是，我们可以安装上一系列自动机器手 <code>&gt;&gt;=</code>，<code>&gt;&gt;=</code> 会自动把质量不合格的手机扔掉，然后移除质量合格的手机上的标签，方便下一个机器检测。</li>
<li>但自动机器手不能把手机自动移往下一个机器，，因此，我们还需要一个传送带 <code>\x -&gt; nextMachine x</code>（Lambda 匿名函数），将移除标签后的手机运输到下一个检测机器。</li>
</ol>
<p>当你运行这段代码，你会得到 <code>Nothing</code>！很神奇，不是吗？我们通过 <code>Maybe</code> 的 <code>Monad</code> 性质，成功地将会产生副作用的单个函数组成在一起，形成了一个可以产生相同副作用的大型函数。</p>
<p>而且 Haskell 还提供了一个语法糖：<code>do</code>，让你可以轻松得应用多个 Monad 到多参数函数上，且不需要写繁琐的 lambda 函数。例如，我们可以改写上面的代码为：<br><figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">do</span> </span><br><span class="line">    x &lt;- mySafeDiv <span class="number">1</span> <span class="number">3</span></span><br><span class="line">    y &lt;- mySafeDiv <span class="number">2</span> <span class="number">0</span></span><br><span class="line">    mySafeDiv x y</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope="" itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/25/hello-world/">

    <span hidden itemprop="author" itemscope="" itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Han">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope="" itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hangary Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2019/01/25/hello-world/" itemprop="url">Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2019-01-25T02:06:13-06:00">
                2019-01-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope="" itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Han</p>
              <p class="site-description motion-element" itemprop="description">Stay Hungry, Stay Foolish</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">4</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/Hangary" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:HangaryLiu@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      

      
        <div class="back-to-top">
          <i class="fa fa-arrow-up"></i>
          
        </div>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Han</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
